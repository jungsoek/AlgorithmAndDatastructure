# 4. 알고리즘 문제 해결 전략

# 4.1 알고리즘 문제 풀이 흐름

## 문제 분류 및 태깅

### 📌 1. 분류 목적

| 목적                        | 설명                                           |
| --------------------------- | ---------------------------------------------- |
| 빠른 해결 전략 결정         | 입력 조건, 요구사항 보고 어떤 기법을 쓸지 판단 |
| 알고리즘/자료구조 반복 학습 | 유사 유형 문제 풀기                            |
| 약점 유형 보완              | 못 푼 문제 유형만 다시 학습 가능               |
| 컨테스트/면접 준비          | 출제 빈도 높은 유형 집중 가능                  |

### 🧭 2. 대표적인 문제 분류 (태그 기준)

#### 🔷 자료구조 기반

| 태그               | 의미                             |
| ------------------ | -------------------------------- |
| 배열               | 단순 인덱싱, 슬라이딩 윈도우     |
| 스택/큐            | 후입선출, 선입선출 구조          |
| 덱(Deque)          | 양방향 처리                      |
| 힙(Priority Queue) | 우선순위 선택                    |
| 트리/이진트리      | DFS, 재귀, LCA, 세그먼트 트리 등 |
| 그래프             | BFS, DFS, MST, 최단경로          |
| 유니온파인드       | 집합 분리, 사이클 판별           |
| 해시               | 빠른 조회, 중복 제거             |

#### 🔷 알고리즘 기반

| 태그                     | 의미                                  |
| ------------------------ | ------------------------------------- |
| 정렬                     | 커스텀 정렬, stable sort 여부         |
| 이분 탐색                | 정렬된 공간에서 조건 만족 최소값 탐색 |
| 그리디                   | 각 단계에서 최적 선택                 |
| 완전탐색                 | 브루트포스, 백트래킹 포함             |
| DFS/BFS                  | 그래프 탐색, 시뮬레이션               |
| DP (동적 프로그래밍)     | 부분 문제 재사용, 메모이제이션        |
| 누적합 / 슬라이딩 윈도우 | 구간합, 최적 구간                     |
| 투 포인터                | 정렬된 구조에서 쌍 탐색               |
| 분할 정복                | 병합정렬, 거듭제곱                    |
| 비트마스킹               | 집합 표현 최적화                      |
| 트라이 / 문자열          | KMP, Z, AC 자동화 등 포함             |
| 수학 / 정수론            | GCD, mod, 소수, 조합, 피보나치 등     |
| 확률 / 기댓값            | 확률 추론, 기대값 계산                |

#### 🔷 고급 주제별

| 태그                       | 설명                            |
| -------------------------- | ------------------------------- |
| 세그먼트 트리 / 펜윅트리   | 구간 쿼리, 구간 업데이트        |
| 최소 공통 조상 (LCA)       | 트리에서 두 노드 사이 관계 추적 |
| 스위핑 / 이벤트 정렬       | 시간순 정렬, 누적 분석          |
| 트리 분할 (HLD, Centroid)  | 트리 경로 문제                  |
| SCC / 위상정렬             | 방향 그래프 분석, 순서 보장     |
| 최대 유량 / 최소 비용 유량 | 네트워크 흐름                   |
| 이분 매칭 / 헝가리         | 할당 문제                       |
| 게임이론 / 그룬디 수       | 승리 조건 판별                  |
| 문자열 해싱 / 롤링 해시    | O(1) 문자열 비교                |

#### 🔷 난이도별 분류 (실전용)

| 난이도 | 예시                                                 |
| ------ | ---------------------------------------------------- |
| 초급   | 그리디, 정렬, 누적합, 구현                           |
| 중급   | 이분 탐색, DP, DFS/BFS, 비트마스킹                   |
| 고급   | 세그먼트 트리, LCA, KMP, 트라이                      |
| 마스터 | 유량, 트리 분할, 스플레이 트리, Convex Hull Trick 등 |

### 🧩 3. 문제 태깅 실전 예시

#### 예시 1

```
문제: 두 수의 최대공약수 구하기
→ 태그: 수학, GCD, 유클리드 알고리즘
```

#### 예시 2

```
문제: 숫자 카드 정렬하기
→ 태그: 우선순위 큐, 그리디
```

#### 예시 3

```
문제: 2차원 격자에서 가장 빠른 탈출 경로
→ 태그: BFS, 시뮬레이션, 그래프
```

#### 예시 4

```
문제: N개의 수로 만들 수 있는 정수의 개수
→ 태그: 비트마스킹, 부분집합, 집합 처리
```

### 📚 태그별 추천 문제 셋 만들기

| 태그    | 추천 학습 세트               |
| ------- | ---------------------------- |
| 그리디  | 동전 문제, 회의실 배정, 배낭 |
| DP      | 계단 오르기, 연속합, LIS     |
| DFS/BFS | 유기농 배추, 안전 영역       |
| 트리    | 부모 찾기, 트리의 지름       |
| 그래프  | MST, 다익스트라, 위상 정렬   |
| 수학    | GCD, 조합, 피보나치, 모듈러  |

### ✅ 정리 요약

| 항목      | 내용                                        |
| --------- | ------------------------------------------- |
| 목적      | 문제 해결 전략 빠르게 결정하기              |
| 분류 기준 | 자료구조, 알고리즘, 난이도, 응용 구조       |
| 태그 실전 | 여러 개 태그가 겹칠 수 있음                 |
| 활용법    | 약점 유형 추적, 분류별 학습, 자동 분류 추천 |

## 제한 조건 분석 → 자료구조 선택 → 알고리즘 선택

### 🧠 알고리즘 문제 해결 3단계:

#### 1️⃣ 제한 조건 분석 → 2️⃣ 자료구조 선택 → 3️⃣ 알고리즘 선택

### 📌 1. 제한 조건 분석 (Input Constraints)

> 문제를 제대로 이해했으면, **입력 크기(범위)**를 보고
>  어떤 알고리즘, 어떤 시간복잡도여야 **통과 가능한지**를 먼저 판단해야 해.

#### 🔎 기준표 (문제의 최대 입력 N 기준)

| N의 범위      | 허용 시간복잡도                           |
| ------------- | ----------------------------------------- |
| N ≤ 20        | O(2ⁿ), O(n!) 가능 (완전탐색, 백트래킹)    |
| N ≤ 100       | O(n³) 가능 (3중 for문 등)                 |
| N ≤ 1,000     | O(n²) 가능 (버블/삽입 정렬, DP 이차원 등) |
| N ≤ 10⁵       | O(n log n), O(n)                          |
| N ≤ 10⁶ ~ 10⁷ | O(n log n) 이하만 가능                    |
| N ≤ 10⁹ 이상  | O(log n), 수학적 풀이 or 이분 탐색만 가능 |

#### 🧠 분석 항목

- **입력 크기 N**: 완전탐색인지, 최적화가 필요한지
- **Q (질문 수)**: 쿼리형 문제인가?
- **값의 범위**: 배열/해시 가능 여부, 정수형 사용 가능 여부
- **정답의 조건**: 최댓값/최솟값/조건 만족 여부?

### 🧰 2. 자료구조 선택 (Data Structure)

> 제한 조건과 문제 성격을 보고 **어떤 자료구조로 문제를 표현할지 결정**

#### ✨ 자주 쓰는 선택 기준

| 상황                              | 추천 자료구조             |
| --------------------------------- | ------------------------- |
| 키와 값을 빠르게 매핑             | HashMap / unordered_map   |
| 정렬된 상태 유지가 중요           | TreeMap / multiset / set  |
| 빠른 최댓값/최솟값 필요           | Heap (priority_queue)     |
| 좌표, 구간의 빠른 합 or 갱신      | 세그먼트 트리 / 펜윅 트리 |
| 문자열 빠른 검색, 접두사 매칭     | Trie                      |
| 최근 사용 기록, 순서 보존         | Deque, LinkedHashMap      |
| 순서 필요 없는 그룹 관리          | Union-Find (Disjoint Set) |
| 순서대로 탐색 (너비/깊이 우선 등) | Queue, Stack              |

### ⚙️ 3. 알고리즘 선택 (Algorithm)

> 자료 구조가 정해졌으면, 이제 **구현할 알고리즘의 종류와 방식**을 결정해야 함

#### 🎯 목적 → 알고리즘 선택 가이드

| 목적                         | 선택할 알고리즘                        |
| ---------------------------- | -------------------------------------- |
| 최단거리                     | 다익스트라, BFS, 플로이드, 벨만-포드   |
| 경로 수 or 경우의 수 계산    | DP, DFS + 메모이제이션                 |
| 특정 조건의 최댓값 or 최소값 | 그리디, 이분 탐색, DP                  |
| 조합/순열 탐색               | 완전탐색, 백트래킹, DFS                |
| 연속된 구간 최대합           | 누적합, 슬라이딩 윈도우, 세그먼트 트리 |
| 정렬 조건 충족               | 커스텀 정렬, Comparator                |
| 트리 구조 처리               | DFS, 세그먼트 트리, LCA                |
| 조건 만족하는 수 찾기        | 이분 탐색, 투 포인터                   |
| 조건을 만족하는 경로 찾기    | DFS/BFS, 유니온 파인드, 플로이드       |
| 반복 문자열 탐색             | KMP, Z 알고리즘, Aho-Corasick          |
| 흐름 최적화, 최대 유량       | Ford-Fulkerson, Dinic, MCMF            |

### 📚 실전 예제 흐름

#### 🔍 예제 1

```
N ≤ 1,000
→ 시간복잡도 O(N²) 가능
→ DP or 이중 for 가능
문제: 최장 증가 부분 수열 (LIS)

→ 배열 자료구조
→ 알고리즘: DP[i] = max(DP[j]) + 1 (j < i, arr[j] < arr[i])
```

#### 🔍 예제 2

```
N = 1,000,000 / Q = 100,000
→ 입력이 크고 쿼리가 많다 → O(log n) 필요

질문: 구간 합 구하기 / 갱신

→ 자료구조: 세그먼트 트리
→ 알고리즘: Segment Tree로 쿼리와 업데이트 처리
```

#### 🔍 예제 3

```
N ≤ 15
→ 완전탐색 가능 → O(2ⁿ)

문제: 가능한 부분집합의 합 중 K에 가장 가까운 것

→ 자료구조: 배열
→ 알고리즘: 백트래킹 or Meet-in-the-middle
```

### ✅ 정리 요약

| 단계              | 질문                                             | 결과 예시                          |
| ----------------- | ------------------------------------------------ | ---------------------------------- |
| 1. 제한 조건 분석 | 시간복잡도는? Q의 수는? 값의 범위는?             | O(n²) 가능 → 완전탐색 OK           |
| 2. 자료구조 선택  | 어떤 구조가 적합한가? 빠른 삽입/탐색이 필요한가? | 배열, 해시, 트리, 세그먼트 트리 등 |
| 3. 알고리즘 선택  | 최댓값? 최소값? 조건 만족? 경우의 수?            | DP, 그리디, 이분 탐색, 유량 등     |

## 시간/공간 복잡도 역산

### 📌 1. 왜 역산이 중요한가?

> 문제 설명에는 대부분 “1초”, “512MB”, “입력 크기 N은 최대 10⁵” 이렇게만 주어진다.
>  즉, **정답이 될 코드의 시간복잡도나 메모리 크기는 직접 역산해야 한다.**

### 🧮 2. 시간 복잡도 역산 기준표

| 시간 제한 | 가능한 연산 수 | 가능한 알고리즘 수준 예시                    |
| --------- | -------------- | -------------------------------------------- |
| 0.5초     | 약 5 × 10⁷     | O(N log N), N ≤ 10⁶ 가능                     |
| 1초       | 약 1~2 × 10⁸   | O(N log N), O(N²) (N ≤ 5000)                 |
| 2초       | 약 3~4 × 10⁸   | O(N log N), O(N²) (N ≤ 7000)                 |
| 5초       | 10⁹ 이상       | O(N³), 완전탐색 (N ≤ 300), 큰 수학 계산 가능 |

> ✅ 일반적으로 `1초 ≈ 1억 연산` 정도로 생각해도 안전하다

### 📦 3. 입력 N에 따른 시간복잡도 역산

| N의 크기      | 시간복잡도 역산 예시                     |
| ------------- | ---------------------------------------- |
| N ≤ 10        | 완전탐색 O(N!), 부분집합 O(2ⁿ) 가능      |
| N ≤ 100       | O(N³) 가능 (DP, 중첩 루프 3중 가능)      |
| N ≤ 1000      | O(N²) 가능 (이중 for문, 기본 DP)         |
| N ≤ 10⁵       | O(N log N), 정렬, 세그먼트 트리 가능     |
| N ≤ 10⁶ ~ 10⁷ | O(N), 해시맵/누적합/슬라이딩 윈도우 가능 |
| N ≤ 10⁹ 이상  | O(log N), 이분탐색, 수학적 계산만 가능   |

### 📐 4. 공간 복잡도 역산 기준표

| 사용 가능 메모리 | 저장 가능한 자료량 (int 기준) |
| ---------------- | ----------------------------- |
| 64MB             | 16M 개 (약 1600만 개)         |
| 128MB            | 32M 개                        |
| 256MB            | 64M 개                        |
| 512MB            | 128M 개                       |
| 1024MB (1GB)     | 256M 개                       |

#### ✅ 기준:

- `bool` 배열: 8배 더 많이 저장 가능 (비트 단위)
- 2차원 배열: N² ≤ 10⁷ 정도가 현실적

### 🔧 5. 예제 문제 역산 흐름

#### 🔍 예제 1

```
N ≤ 100,000, Q ≤ 100,000, 시간 제한: 1초

→ O(N log N) or O(Q log N) 가능
→ O(N²) 불가능

가능한 알고리즘: 이분 탐색, 세그먼트 트리, 해시
```

#### 🔍 예제 2

```
N ≤ 100, 시간 제한: 2초

→ O(N³) 가능
→ 다이나믹 프로그래밍, 플로이드-워셜

가능: O(N³) DP
```

#### 🔍 예제 3

```
N ≤ 15, 시간 제한: 1초

→ 완전탐색 O(2ⁿ) 가능
→ 백트래킹, 비트마스크, 부분집합

가능: brute-force, meet-in-the-middle
```

### 💡 6. 실전 테크닉

#### ✅ 시간복잡도 추정 공식

```
N = 입력 크기, T = 시간 제한(초)

허용된 연산 수 ≈ T × 100,000,000

→ 시간복잡도 계산:
O(N²) 가능? → N² ≤ 10⁸인지 확인
O(N log N) 가능? → N log N ≤ 10⁸인지 확인
```

#### ✅ 메모리 추정

```
배열 int arr[1000000]; → 4MB
bool is_prime[10000000]; → 약 1.2MB
int map[1000][1000]; → 4MB
```

### 🧠 전체 흐름 예시

```
문제:
N ≤ 10⁵, Q ≤ 10⁵, 1초 제한

→ 연산: 최대 2 × 10⁵번 → O(N log N) 가능

1. 제한 분석 → 시간: O(N log N), 공간: 100MB 이하
2. 자료구조: prefix sum, segment tree, heap
3. 알고리즘: 이분 탐색 / 슬라이딩 윈도우 / 세그 트리
```

### ✅ 정리 요약

| 분석 대상 | 기준 / 판단법 예시                                       |
| --------- | -------------------------------------------------------- |
| 시간제한  | 1초 ≈ 10⁸ 연산                                           |
| 입력 N    | O(N²) 허용 여부 판단                                     |
| 쿼리 수 Q | O(Q log N) vs O(Q)                                       |
| 공간 제한 | int 100MB ≈ 25M개                                        |
| 판단 흐름 | **제한 → 연산 수 역산 → 시간/공간 판단 → 알고리즘 선택** |

# 4.2 테스트 및 디버깅

## 입력 케이스 설계

### 📌 1. 왜 입력 케이스 설계가 중요한가?

| 목적                         | 설명                                        |
| ---------------------------- | ------------------------------------------- |
| 알고리즘 검증                | 코드가 모든 상황에서 제대로 작동하는지 확인 |
| 디버깅                       | 특정 조건에서만 발생하는 버그 추적          |
| 채점 시스템 구성             | 예외 입력, 경계 입력, 무작위 입력 생성      |
| 시간/메모리 제한 하중 테스트 | 시간 초과(TLE), 메모리 초과(MLE) 잡아내기   |

### 🧠 2. 입력 케이스 분류

#### ① **기본 입력 (Small Valid Input)**

- 작은 크기, 손으로 계산 가능한 값
- 알고리즘이 제대로 작동하는지 1차 확인

```
예: N = 3, arr = [1, 2, 3]
```

#### ② **경계 입력 (Edge Case)**

- 입력이 가장 작거나 가장 큼
- 일반적인 알고리즘에서 경계 조건 실수 발생 가능

```
예:
- N = 0 (빈 배열, 공집합)
- N = 1 (단일 요소)
- N = 1e5 (최대 크기)
- arr[i] = 0 or 1e9 (값의 경계)
```

#### ③ **특수 입력 (특정 패턴)**

- 정렬됨, 역정렬, 모두 같음, 교차 패턴 등
- 정렬 기반 알고리즘, 슬라이딩 윈도우, 투 포인터 등에서 특이 반응

```
- 오름차순: [1, 2, 3, ..., N]
- 내림차순: [N, N-1, ..., 1]
- 모두 같음: [7, 7, 7, ..., 7]
- 지그재그: [1, 1000000, 2, 999999, 3, 999998, ...]
```

#### ④ **랜덤 입력 (Random Valid Input)**

- 전체 범위에서 무작위로 생성
- 평균 성능 테스트 및 통계적 안정성 확인

```
import random
print(100000)
print(' '.join(str(random.randint(1, 10**9)) for _ in range(100000)))
```

#### ⑤ **최악 입력 (Worst-case for 알고리즘)**

- 시간복잡도 상 가장 오래 걸리게 유도하는 입력
- Brute-force나 O(N²) 알고리즘을 **시간 초과 유도**

```
예:
- 정렬된 입력에서 이분탐색 아닌 선형탐색
- 트리 → 선형 형태 (체인 트리)
- DP에서 overlapping subproblem 유도
```

#### ⑥ **코너 케이스 (논리적 모순 유발)**

- 0개, 1개, 조건이 중첩됨, 같은 값이 반복됨
- 분기문, 정렬, 조건 필터에서 논리 실수 유도

```
- N = 2, but arr[0] == arr[1]
- 모든 조건을 동시에 만족하는 값
- 조건이 모순되는 입력이 섞인 경우 (ex. A[i] > B[i] always인데 한 곳만 반대)
```

### 🧰 3. 입력 설계 전략 요약표

| 유형      | 크기/특징                 | 목적                  |
| --------- | ------------------------- | --------------------- |
| 기본 입력 | 작고 단순                 | 초기 동작 확인        |
| 경계 입력 | 0, 1, 최대값              | 예외 처리 확인        |
| 특수 입력 | 정렬됨, 반복됨, 대칭 등   | 알고리즘 안정성 확인  |
| 랜덤 입력 | 전체 범위에서 무작위 생성 | 평균 성능 확인        |
| 최악 입력 | 알고리즘 최대시간 유도    | 시간복잡도 검증       |
| 코너 입력 | 조건 경계/중복/모순       | 조건문/분기 오류 유도 |

### 🔧 4. 자동 입력 생성기 만들기 예시 (Python)

```
# 랜덤 정렬된 입력 생성기
import random

N = 100000
arr = sorted(random.randint(1, 10**9) for _ in range(N))

print(N)
print(' '.join(map(str, arr)))
```

### 🧠 실전 예: 문제 “k번째로 작은 수 찾기”

**입력 조건**: N ≤ 100000, 값 ≤ 10⁹
**입력 설계**:

- ✅ N = 1 → [42]
- ✅ N = 5, arr = [3, 1, 4, 2, 5]
- ✅ N = 10⁵, arr = [1, 2, 3, ..., 100000]
- ✅ N = 10⁵, arr = [100000, 99999, ..., 1]
- ✅ N = 10⁵, arr = [7, 7, ..., 7]
- ✅ N = 10⁵, arr = [1, 1, ..., 1, 10⁹]

### ✅ 정리 요약

| 항목      | 설명                                            |
| --------- | ----------------------------------------------- |
| 입력 목적 | 알고리즘을 다양한 상황에서 검증                 |
| 핵심 유형 | 기본, 경계, 랜덤, 특수, 최악, 코너              |
| 유의할 점 | 시간 초과(TLE), 런타임 오류(RE), 논리 오류 검출 |
| 생성 도구 | 수동 / 스크립트 / Fuzzing 툴 등                 |

## 엣지 케이스 탐색

### 📌 1. 엣지 케이스란?

> 정상적으로 설계된 알고리즘이나 코드가
>  **비정상적인 입력/경계/극단적 상황**에서 잘못된 결과를 낼 수 있는 특수한 입력

### 🚩 2. 왜 엣지 케이스가 중요한가?

| 문제                        | 실제 영향                     |
| --------------------------- | ----------------------------- |
| **IndexError, NullPointer** | 런타임 에러(RE) 발생          |
| **무한 루프 or 분기 실패**  | 시간 초과(TLE), 논리 오류     |
| **0 또는 1 크기 예외**      | 기저 조건 미처리              |
| **정렬/탐색 실패**          | 정렬된 상태 가정 깨짐         |
| **조건식 경계 실패**        | 비교 연산 `≤`, `<`, `==` 실수 |

### 🧪 3. 엣지 케이스 유형별 탐색 전략

#### ✅ [1] **입력 크기 극한**

| 조건       | 테스트                 |
| ---------- | ---------------------- |
| N = 0      | 빈 입력 처리 확인      |
| N = 1      | 단일 요소              |
| N = 2      | 최소 비교 구조         |
| N = 최대값 | 시간복잡도 한계 테스트 |

> ❗ 예외 처리 안하면 `SegFault`, `RE`, `IndexError` 발생 가능

#### ✅ [2] **값의 경계**

| 조건             | 예시 테스트                   |
| ---------------- | ----------------------------- |
| 최소값           | 0, -10⁹                       |
| 최대값           | 10⁹                           |
| 같은 값 반복     | [5, 5, 5, 5]                  |
| 음수/0 포함 여부 | 정렬, 곱셈 등에서 오작동 가능 |

> 예: `0으로 나누기`, `절댓값`, `부등식 비교 오류`

#### ✅ [3] **정렬 및 순서 관련**

| 패턴             | 영향                              |
| ---------------- | --------------------------------- |
| 이미 정렬된 배열 | 정렬 알고리즘 최선/최악 구간 탐색 |
| 역정렬된 배열    | 선택/삽입정렬 등 최악 조건 유도   |
| 지그재그 배열    | 정렬 로직 테스트                  |
| 모두 같은 값     | 비교 로직 무력화 가능             |

#### ✅ [4] **분기 조건 실패**

- 조건문에서 빠뜨리기 쉬운 분기:

```
if (A[i] < x) ... 
else if (A[i] > x) ...  ← **== 처리 누락**
```

- 연산에서의 `0`, `1`, `mod`, `negative`, `overflow`는 전형적인 취약점

#### ✅ [5] **자료구조 특화 엣지**

| 구조      | 엣지 케이스                                          |
| --------- | ---------------------------------------------------- |
| 스택/큐   | 비어 있을 때 pop                                     |
| 해시맵    | 키 없음, 해시 충돌                                   |
| 트리      | 루트만 있는 경우, 편향 트리                          |
| 세그 트리 | 리프가 1개일 때, 구간이 겹침                         |
| 그래프    | 고립 노드, 자기 루프, 이중 간선, 무방향 vs 방향 혼동 |

#### ✅ [6] **수학 / 나눗셈 엣지**

- `a % b` → b = 0
- 음수 나눗셈 방향성 혼동 (`-3 / 2 == -1` or -2)
- 오버플로우: `int x = 1e9 * 1e9`
- 모듈러 역원 존재 여부 (GCD(a, m) ≠ 1이면 불가)

### 🔧 4. 엣지 케이스 체크리스트

```
✅ N = 0, 1, max
✅ 모든 값이 동일
✅ 정렬된 상태, 역정렬
✅ 부호(+, -, 0) 혼합
✅ 동일 값이 여러 번 등장
✅ 조건문이 정확히 나눠지는가?
✅ 나눗셈/나머지/0 처리
✅ 그래프가 연결되어 있지 않음
✅ 재귀 깊이 초과 or 스택 오버플로우
```

### 🧠 실전 문제 예시로 적용

#### 🎯 문제: "수열에서 두 수의 차가 K 이하인 쌍의 개수 구하기"

```
입력:
- N ≤ 100000
- arr[i] ≤ 1e9
- K ≥ 0
```

#### 탐색해야 할 엣지 케이스:

| 조건         | 테스트 입력 예시       |
| ------------ | ---------------------- |
| N = 1        | [3], K = 0             |
| 모두 같은 수 | [5, 5, 5, ..., 5]      |
| 정렬된 입력  | [1, 2, 3, ..., N]      |
| 역정렬       | [N, N-1, ..., 1]       |
| 최대 수치    | [1e9, ..., 1e9]        |
| K = 0        | 차이 == 0 인 쌍만 허용 |

### ✅ 정리 요약

| 항목          | 예시                                   |
| ------------- | -------------------------------------- |
| 입력 크기     | N = 0, 1, max                          |
| 값 경계       | 최소, 최대, 음수/0 포함                |
| 패턴          | 정렬됨, 역정렬, 지그재그               |
| 자료구조 특이 | 비어있을 때, 루트만 존재, 자가 순환 등 |
| 수학 경계     | mod 0, 나눗셈 0, GCD 실패              |

## 디버깅 도구 활용 및 트레이스 분석

### 📌 1. 왜 디버깅이 중요한가?

> “구현이 다 끝났는데 왜 틀릴까?”
>  이럴 때 직접 변수 값을 **추적하고, 흐름을 시각화**하며
>  **논리 흐름을 거슬러 올라가서 오류를 추적**해야 해.

### 🧠 2. 디버깅 도구 종류 (C++ 기준, Python은 별도)

| 도구                       | 설명                                     |
| -------------------------- | ---------------------------------------- |
| `gdb`                      | GNU 디버거, 터미널에서 step-by-step 분석 |
| `lldb`                     | LLVM 디버거 (Mac/Clang 계열)             |
| `valgrind`                 | 메모리 누수, 잘못된 접근 추적            |
| `printf`, `cerr`, `cout`   | 고전적이지만 강력한 trace 출력           |
| IDE 디버거 (VSCode, CLion) | 브레이크포인트, 변수창 지원              |
| `assert`                   | 조건 불충족 시 중단 후 오류 위치 확인    |
| `tracemalloc` (Python)     | 메모리 누수 추적                         |
| `pdb` (Python)             | 파이썬 인터프리터 기반 스텝 디버거       |

### 📎 3. 디버깅 단계별 접근

#### 🔍 Step 1. 증상 분류

| 증상 종류        | 원인 가능성                              |
| ---------------- | ---------------------------------------- |
| 런타임 오류(RE)  | 인덱스 초과, 0으로 나눔, null 접근       |
| 시간 초과(TLE)   | 무한 루프, O(N²) 이상 알고리즘           |
| 틀렸습니다(WA)   | 경계/조건 오류, 자료형 오류, 반례 미처리 |
| 메모리 초과(MLE) | 배열 사이즈 초과, 무한 재귀              |

#### 🔍 Step 2. 주요 의심점 추적

| 위치           | 디버깅 방식                          |
| -------------- | ------------------------------------ |
| 반복문         | 루프 조건/횟수, 무한루프 여부        |
| 조건문/분기    | 실제 분기 진입 여부                  |
| 배열/자료구조  | 크기, 경계 접근 여부                 |
| 함수 호출      | 호출 순서, 파라미터 전달 확인        |
| 정렬/탐색 결과 | 정렬이 정확한지, 탐색 실패 조건 확인 |

#### 🔍 Step 3. 트레이스 출력 (Print Debugging)

**C++ 예시**

```
for (int i = 0; i < N; i++) {
    cerr << "arr[" << i << "] = " << arr[i] << "\n";
}
```

**Python 예시**

```
for i in range(N):
    print(f"arr[{i}] = {arr[i]}")
```

### 🛠️ 4. gdb 간단 사용법 (C++)

#### 1️⃣ 컴파일 시 디버그 플래그 추가

```
g++ -g main.cpp -o main
```

#### 2️⃣ 디버깅 시작

```
gdb ./main
```

#### 3️⃣ 주요 명령어

| 명령어       | 기능                      |
| ------------ | ------------------------- |
| `break main` | main 함수에서 중단점 설정 |
| `break NNN`  | 특정 줄 번호에서 중단     |
| `run`        | 프로그램 실행             |
| `next`       | 다음 줄로 이동 (한 줄씩)  |
| `print var`  | 변수값 출력               |
| `backtrace`  | 함수 호출 스택 출력       |
| `quit`       | 디버깅 종료               |

### 📈 5. 트레이스 분석 기법

| 분석 기법             | 예시 사용                          |
| --------------------- | ---------------------------------- |
| 입력/출력 확인        | 입출력 안 맞는 경우 확인           |
| 조건문 진입 여부 추적 | `cerr << "IF 조건 진입"`           |
| 루프 진입/탈출 추적   | `cerr << "Loop start", "Loop end"` |
| 특정 인덱스 접근 확인 | `cerr << "arr[" << i << "]"`       |
| 중간 계산값 출력      | prefix sum, dp[i], ans 값 등       |

### ✅ 6. 실전 디버깅 팁

- **무한 루프?** → 반복 횟수 제한 출력 (예: i++ 1000 이상 시 종료)
- **틀렸습니다?** → 단순 입력 직접 테스트 후 trace 출력
- **자료형 주의**: `int × int → long long`
- **절댓값, mod, 경계 확인**
- **함수 호출 스택 추적**: 재귀 호출 순서, 파라미터 확인
- **중간 상태 저장**: 상태 변화 직전 직후 `print/cerr`

### 🧪 실전 예제: 경로 수 계산 DP[i] = DP[i-1] + DP[i-2]

#### 증상: `틀렸습니다`

#### 트레이스 출력 예시

```
for (int i = 0; i <= N; ++i)
    cerr << "DP[" << i << "] = " << DP[i] << "\n";
```

→ DP[0]이 초기화 안 됨 → 초기값 오류

### ✅ 정리 요약

| 항목            | 설명                               |
| --------------- | ---------------------------------- |
| 주요 도구       | gdb, cerr, assert, IDE 디버거      |
| 증상별 분석법   | RE, TLE, WA, MLE 구분 후 원인 추적 |
| 트레이스 분석법 | 조건문, 반복문, 배열 접근 추적     |
| 중간값 출력     | 상태 변화 시점 추적                |
| 스택 추적       | 재귀/함수 호출 오류 분석           |

# 4.3 실전 문제 유형별 접근법

## 구현(Implementation)

### ✅ 1. 구현 문제란?

> 알고리즘 아이디어보다 **정확한 시뮬레이션과 구현 능력**이 중요한 문제.

- 수학적 풀이 없이도 해결 가능
- 주어진 조건을 **정확히 그대로 따라가는 것이 핵심**
- 실전에서는 난이도 중하~중상 문제 중 가장 많이 등장

### 📌 2. 대표 특징

| 항목             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| 알고리즘?        | 특별한 알고리즘 없이도 풀림 (경우의 수/조건 분기/시뮬레이션) |
| 복잡도           | `O(N^2)` 또는 `O(N^3)`까지도 자주 등장                       |
| 핵심 능력        | 문자열, 배열 인덱스 처리, 조건 분기, 반복문                  |
| 실수 발생 포인트 | 인덱스 경계, 조건 순서, 정렬 기준, 오탈자                    |

### 🧠 3. 구현 문제의 접근 전략

#### ✅ 1) 문제 요구 사항을 *완전히* 이해하자

- 생략 없이, **지문에서 말하는 그대로 구현**
- 변수명이나 흐름을 문제와 최대한 일치시키면 실수 방지됨

#### ✅ 2) 시뮬레이션 전략 수립

- 실제로 **움직임, 변화, 계산**이 있는 문제 → 매 시점마다 상태 추적
- 시간 흐름 or 명령 수행 or 패턴 반복 등

#### ✅ 3) 함수 분리로 복잡도 제어

- 예: 이동 함수, 체크 함수, 출력 함수 따로 만들기
- 깔끔한 구조 유지 → 디버깅 쉬움

#### ✅ 4) 디버깅 친화적인 출력 넣기

- 중간 상태 출력: `print(f"step {i}:", arr)`
- 범위 밖 인덱스 체크, 무한 루프 감지

### 🧩 4. 구현 문제 자주 등장하는 주제

| 주제                   | 설명 / 키워드                                  |
| ---------------------- | ---------------------------------------------- |
| 문자열 처리            | 슬라이싱, 아스키코드, 정규식, `split/join`     |
| 시뮬레이션             | 이동, 명령 수행, 상태 변화                     |
| 좌표계 / 2차원 배열    | 시계/반시계 방향 회전, 테두리 조작             |
| 큐/덱 기반 명령어 시뮬 | `push`, `pop`, `front`, `back`                 |
| 정렬 조건              | 다중 기준 정렬 (`key=lambda x: (x[1], -x[0])`) |
| 조건문+루프+배열       | **전형적인 구현 골격**                         |

### 🪜 5. 전형적인 구현 문제 예시

#### ✅ A. 시뮬레이션 - 로봇 이동 문제

```
dx = [0, 1, 0, -1]  # 동남서북
dy = [1, 0, -1, 0]
dir = 0  # 시작 방향: 동쪽

for cmd in commands:
    if cmd == 'L':
        dir = (dir - 1) % 4
    elif cmd == 'R':
        dir = (dir + 1) % 4
    elif cmd == 'F':
        x += dx[dir]
        y += dy[dir]
```

#### ✅ B. 문자열 - 암호 해독기

```
s = input().strip()
decoded = ''
for i in range(0, len(s), 2):
    ch = chr(int(s[i:i+2]) + ord('a') - 1)
    decoded += ch
print(decoded)
```

#### ✅ C. 정렬 - 조건 2개 이상

```
arr = [(name, age), ...]
arr.sort(key=lambda x: (x[1], x[0]))  # 나이, 이름순
```

### 🚨 6. 자주 실수하는 포인트

| 실수 유형        | 설명                                 |
| ---------------- | ------------------------------------ |
| 인덱스 초과      | 범위 체크 없이 접근                  |
| 초기화 누락      | 매 테스트케이스마다 배열 초기화 잊음 |
| 조건 순서 오류   | `if-elif-else`에서 순서 잘못됨       |
| 문자열 처리 실수 | 공백 포함, 대소문자 구분 안 됨       |
| 무한 루프        | 탈출 조건 누락                       |
| 부등호 실수      | `>=` vs `>` 구분 안 됨               |

### 🧠 7. 구현에 강해지는 방법

- 📌 **직접 손으로 시뮬레이션 해보기**
- 📌 10줄 미만 함수로 **분리해서 개발**
- 📌 대표 구현 문제 **10~20문제 반복 풀이**

### ✅ 핵심 요약

| 키워드          | 설명                                      |
| --------------- | ----------------------------------------- |
| 핵심 능력       | 정확한 조건 분기, 반복, 배열/문자열 조작  |
| 주요 주제       | 시뮬레이션, 문자열, 좌표계, 조건 조합     |
| 알고리즘 의존도 | 낮음 – 실전 구현력이 핵심                 |
| 추천 연습       | BOJ - 덱, 큐 시뮬, 달팽이 배열, 블록 이동 |

## 시뮬레이션(Simulation)

### ✅ 1. 시뮬레이션이란?

> 주어진 조건과 규칙을 **그대로 따라가며**,
>  **시간의 흐름**, **상태 변화**, **행위 결과**를
>  **정확하게 추적하고 구현**하는 문제 유형.

### 📌 2. 구현과 시뮬레이션의 차이

| 항목 | 구현(Implementation)        | 시뮬레이션(Simulation)          |
| ---- | --------------------------- | ------------------------------- |
| 핵심 | 조건 분기 정확성            | 상태 변화의 순차적 재현         |
| 관점 | 정적인 처리                 | **시간 흐름 + 상태 갱신**       |
| 유형 | 배열/문자열 처리, 규칙 재현 | 게임, 로봇, 퍼즐, 맵 시뮬레이션 |

### 🧠 3. 시뮬레이션 문제의 핵심 전략

#### ✅ 1) 문제 상황을 **시각화**하라

- 2차원 격자, 게임판, 맵 등은 **손으로 직접 그려가며 추적**해야 실수가 줄어듦

#### ✅ 2) 상태(State)를 관리하라

- 보통 다음과 같은 상태를 정확히 기록하고 업데이트해야 함:
  - 현재 위치
  - 방향 (dir)
  - 시간
  - 각 셀의 상태 (value, visited, flags)
  - 임시 상태 → 다음 상태로 옮기는 **딥카피 시뮬레이션**

#### ✅ 3) 시간 기반 루프

- 대부분 `for time in range(T):` 형태의 **시점별 반복**이 존재함
- 시간 순으로 정확히 상태를 업데이트하는 게 핵심

### 🔄 4. 자주 등장하는 시뮬레이션 패턴

| 패턴           | 설명                           |
| -------------- | ------------------------------ |
| 2차원 격자     | 이동, 회전, 인접 탐색          |
| 회전 시뮬      | 배열 회전, 큐브 돌리기         |
| 시간 경과      | T초 후 상태 추적               |
| 퍼즐 상태 전이 | 블록 내리기, 퍼지기, 매치 처리 |
| BFS 기반 확산  | 불, 바이러스, 전염병 등        |
| 캐릭터 이동    | 로봇, 캐릭터의 명령 수행       |

### 🧩 5. 전형적 시뮬레이션 코드 템플릿

#### ✅ 방향 벡터 (2D 격자 기준)

```
# 상, 하, 좌, 우
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
```

#### ✅ 이동 명령 시뮬레이션

```
for cmd in commands:
    if cmd == 'L':
        dir = (dir - 1) % 4
    elif cmd == 'R':
        dir = (dir + 1) % 4
    elif cmd == 'F':
        nx = x + dx[dir]
        ny = y + dy[dir]
        if valid(nx, ny):
            x, y = nx, ny
```

#### ✅ 시간 흐름 기반 처리

```
for t in range(T):
    update_map()
    move_entities()
    check_end_conditions()
```

### 📚 6. 대표 문제 유형 예시

| 유형             | 예시 설명                         |
| ---------------- | --------------------------------- |
| 달팽이 배열      | 숫자를 나선형으로 채움            |
| 로봇 시뮬레이션  | 방향 회전 + 이동 처리             |
| 블록 이동/합치기 | 2048 게임, 상하좌우 이동          |
| 구슬 이동        | 벽, 중력, 충돌 처리               |
| 불/전염병 확산   | BFS 기반 확산 처리                |
| 퍼즐 판 시뮬     | Candy Crush, 뿌요뿌요류 블록 정리 |

### 🚨 7. 시뮬레이션에서 자주 하는 실수

| 실수 유형             | 설명                                                 |
| --------------------- | ---------------------------------------------------- |
| 현재 상태를 바로 바꿈 | 동시에 이동/변화해야 하는데 순차적으로 바꿔버림      |
| 경계 체크 누락        | 인덱스 초과, 음수 접근                               |
| 조건문 순서 오류      | 조건 충족 순서가 바뀌면 결과도 다름                  |
| 방문 배열 초기화 누락 | 반복 시 매번 visited 초기화 필요                     |
| 깊은 복사 문제        | `a = b[:]` or `deepcopy` 안 쓰면 상태 공유 오류 발생 |

### 🛠️ 8. 시뮬레이션 디버깅 팁

- 💡 **중간 출력 필수**

  ```
  print(f"time={t}, pos={x},{y}, state={map}")
  ```

- 💡 `copy.deepcopy()`로 다음 상태 분리

- 💡 상태별로 **함수로 분리**해서 복잡도 분산

### ✅ 핵심 요약

| 키포인트         | 내용                                        |
| ---------------- | ------------------------------------------- |
| 핵심 능력        | 상태 추적, 시간 흐름 처리, 조건 처리        |
| 자주 나오는 요소 | 2차원 격자, 방향 벡터, 동시에 이동하는 구조 |
| 난이도 영향 요소 | 조건 복잡도, 예외 처리, 병렬 처리 여부      |
| 디버깅 필수      | 중간 출력, visited/log, 임시 배열 사용 등   |

## 완전 탐색(Brute Force)

### ✅ 1. 완전 탐색이란?

> 가능한 모든 경우의 수를 **전부 생성**하고,
>  각 경우를 **하나씩 검사**하여 정답을 찾는 방식.

- **정확성 100% 보장**
- 가장 **직관적**이고 **쉬운 알고리즘**
- 단점: 경우의 수가 많으면 시간 초과 발생

### 📌 2. 완전 탐색의 핵심 조건

| 조건                    | 설명                                                  |
| ----------------------- | ----------------------------------------------------- |
| 입력 크기가 작아야 함   | 일반적으로 N ≤ 10~12 이내                             |
| 상태 공간이 유한해야 함 | 조합/순열/부분집합/배열/맵 등 가능한 상태 개수가 유한 |
| 탐색이 단순해야 함      | 각 경우에서 계산이 너무 복잡하면 사용 어려움          |

### 🧠 3. 완전 탐색 접근 전략

#### ✅ 1) 경우의 수 파악

- **순열(permutation)**: 순서 중요, 중복 없이 나열
- **조합(combination)**: 순서 무관, 중복 없이 고르기
- **부분집합(subset)**: 각 원소마다 선택 여부 (2ⁿ)
- **중복 포함 탐색**: 중복 순열, 중복 조합 등

#### ✅ 2) 탐색 결과의 유효성 검사

- 조건을 만족하는 경우만 정답 후보로 인정
- isValid 함수 또는 조건문으로 검사

#### ✅ 3) 최댓값/최솟값 갱신

- 최대 점수, 최소 거리, 최단 시간 등 업데이트

### 🔢 4. 주요 완전 탐색 유형

| 유형           | 설명                                |
| -------------- | ----------------------------------- |
| 모든 순열 생성 | `itertools.permutations`, 재귀 순열 |
| 모든 조합 생성 | `itertools.combinations`, 재귀 조합 |
| 모든 부분집합  | 비트마스킹 or 재귀                  |
| 중첩 반복문    | 직접 모든 경우를 반복               |

### 🧩 5. 대표 패턴별 예시

#### ✅ A. 순열 (순서 O, 중복 X)

```
from itertools import permutations
for p in permutations([1, 2, 3]):
    print(p)  # (1, 2, 3), (1, 3, 2), ...
```

#### ✅ B. 조합 (순서 X, 중복 X)

```
from itertools import combinations
for c in combinations([1, 2, 3, 4], 2):
    print(c)  # (1, 2), (1, 3), ...
```

#### ✅ C. 부분집합 (2ⁿ개 생성)

```
arr = [1, 2, 3]
n = len(arr)
for i in range(1 << n):  # 0 ~ 2ⁿ - 1
    subset = []
    for j in range(n):
        if i & (1 << j):
            subset.append(arr[j])
    print(subset)
```

#### ✅ D. 중첩 반복문 예시 (브루트포스 조합)

```
for a in range(1, 10):
    for b in range(1, 10):
        if a + b == 10:
            print(a, b)
```

### 🚨 6. 자주 하는 실수

| 실수 유형 | 설명                                              |
| --------- | ------------------------------------------------- |
| 중복 탐색 | 예: (a, b)와 (b, a)를 따로 세는 경우              |
| 조건 누락 | 올바른 조건이 빠져 오답 발생                      |
| 배열 변경 | 탐색 중 원본 배열이 변경되는 문제                 |
| 시간 초과 | 조건 없이 탐색 범위가 너무 큼 (최대 10! 정도까지) |

### 🛠️ 7. 시간 복잡도 기준

| 크기(N) | 최대 시도 횟수 (N!) | 적정 여부          |
| ------- | ------------------- | ------------------ |
| 5       | 120                 | 👍 완전 탐색 가능   |
| 8       | 40,320              | 👍 괜찮음           |
| 10      | 3,628,800           | ⚠️ 주의             |
| 12 이상 | 수천만 이상         | ❌ 완전 탐색 어려움 |

### ✅ 8. 활용 예시 문제 유형

| 문제 유형            | 설명                             |
| -------------------- | -------------------------------- |
| 암호 조합, 열쇠 찾기 | 모든 조합 확인                   |
| 최단 경로            | 모든 경로 순회 (TSP 문제 등)     |
| 두 숫자 합           | 모든 쌍 탐색                     |
| 체스판 문제          | N-Queen, 체스 말 이동            |
| 게임 시뮬            | 2048, 퍼즐 조작의 모든 방향 조합 |

### ✅ 핵심 요약

| 키포인트  | 설명                             |
| --------- | -------------------------------- |
| 사용 조건 | 입력 크기 작고 경우의 수 유한    |
| 접근법    | 모든 경우 생성 + 조건 확인       |
| 구현 도구 | itertools, 비트마스킹, 중첩 반복 |
| 주의      | 중복 방지, 조건 누락, 시간 초과  |

## 최적화(Optimization)

### ✅ 1. 최적화란?

> 가능한 모든 해 중에서
>  **가장 좋은 해(최댓값, 최솟값, 최소 비용, 최대 이익 등)**를
>  **찾는 알고리즘 전략** 또는 **문제 해결 방식**.

### 📌 2. 최적화 문제의 구조

| 구성 요소                      | 설명                             |
| ------------------------------ | -------------------------------- |
| 탐색 공간 (Search Space)       | 가능한 모든 해의 집합            |
| 평가 함수 (Objective Function) | 해의 ‘좋고 나쁨’을 판단하는 기준 |
| 최적 조건                      | 최대화 or 최소화 목표            |

### 🧠 3. 최적화 문제 해결 전략

#### ✅ 1) 완전 탐색 기반

- 가능한 모든 해를 다 탐색한 후 **최댓값/최솟값 갱신**
- 단점: 시간복잡도 폭발 위험
- 적용: 입력이 매우 작을 때 (N ≤ 10)

#### ✅ 2) 이진 탐색 응용 (Parametric Search)

- 해를 찾는 게 아니라, **조건을 만족하는 가장 큰/작은 값**을 찾는 것
- 대표 예시: **공유기 설치, 나무 자르기, 배 분배 문제 등**

```
# 예: 가장 짧은 거리의 최댓값을 구하라
left, right = 1, max_possible
while left <= right:
    mid = (left + right) // 2
    if check(mid):  # 조건 만족?
        result = mid
        left = mid + 1
    else:
        right = mid - 1
```

#### ✅ 3) 그리디 알고리즘 (Greedy)

- 각 단계에서 **가장 좋아 보이는 선택**을 계속함
- 항상 최적해를 보장하진 않음 → **증명 필수**
- 적용 예시: 활동 선택, 회의실 배정, Huffman 코딩

#### ✅ 4) 동적 계획법 (DP)

- **최적 부분 구조** + **중복 부분 문제**
- 이전 결과를 기억하며 계산 → 시간 줄임
- Knapsack, LIS, LCS, Matrix Chain Multiplication

#### ✅ 5) 수학적 최적화 (정수, 실수 범위)

- 미분, 이차함수, 삼분 탐색 등
- 실수의 극값을 찾는 문제
- 예시: 거리의 합이 최소가 되는 지점, 함수 최소값

```
# 삼분 탐색 (실수 범위 최솟값)
def ternary_search(low, high):
    for _ in range(100):
        m1 = low + (high - low) / 3
        m2 = high - (high - low) / 3
        if f(m1) < f(m2):
            high = m2
        else:
            low = m1
    return f((low + high) / 2)
```

### 🧩 4. 최적화 문제 대표 유형

| 유형                 | 설명                           |
| -------------------- | ------------------------------ |
| 배낭 문제 (Knapsack) | 제한된 용량 내 최대 가치       |
| 일정 스케줄링        | 최소 인원/시간으로 최대 수익   |
| 거리 최소화          | 집합 간 거리 합 최소           |
| 자원 분배            | CPU, 용량 등 최대 효율 분배    |
| 비용 최소화          | 그래프 탐색 or 경로 비용 문제  |
| 게임/경쟁 전략       | 승률/점수 최대화 시나리오 구성 |

### 🔍 5. 실전 문제 예시

| 문제                       | 전략            |
| -------------------------- | --------------- |
| 나무 자르기 (백준 2805)    | 이진 탐색       |
| 공유기 설치 (백준 2110)    | 이진 탐색       |
| 무게 제한 트럭 (백준 1939) | MST + 이진 탐색 |
| 회의실 배정                | 그리디          |
| 최장 증가 수열             | DP + 이분 탐색  |
| 0-1 Knapsack               | DP              |

### 🚨 6. 자주 하는 실수

| 실수 유형                          | 설명                          |
| ---------------------------------- | ----------------------------- |
| 조건을 만족하는 지점만 찾고 끝냄   | 최댓값/최솟값 갱신 누락       |
| 그리디가 최적이라는 증명 없이 사용 | 틀릴 수 있음                  |
| 탐색 범위 설정 미스                | 이진 탐색 상한/하한 잘못 잡음 |
| 실수 오차 문제 무시                | 삼분 탐색 시 EPS 설정 필요    |

### ✅ 7. 핵심 요약

| 항목        | 설명                             |
| ----------- | -------------------------------- |
| 핵심 질문   | 가능한 해 중 가장 좋은 해는?     |
| 주요 기법   | 완전 탐색, 이진 탐색, DP, 그리디 |
| 선택 기준   | 경우의 수 크기, 조건의 성질      |
| 시간 복잡도 | 최적화 기법을 쓰면 줄일 수 있음  |

## 수학(Mathematics)

### ✅ 1. 수학 유형 문제란?

> 특정 알고리즘이 아닌, **수학적인 지식과 규칙, 사고력**을 이용하여
>  **문제의 구조를 해석하거나, 효율적으로 계산하는 문제 유형**이야.

### 🧠 2. 수학 문제 유형 핵심 분류

| 유형           | 설명                   | 주요 도구                            |
| -------------- | ---------------------- | ------------------------------------ |
| 약수/배수/소수 | 정수의 성질 이용       | 유클리드 호제법, 에라토스테네스의 체 |
| 수열/등차/등비 | 패턴 추론, 합 공식     | 등차합, 시그마 계산                  |
| 조합론         | 경우의 수 세기         | 팩토리얼, `nCr`, `nPr`, 파스칼       |
| 나머지 연산    | 모듈러 연산, 역원      | `%`, `mod`, 오일러 정리              |
| 수학적 최적화  | 최대/최소, 식의 구조화 | 이차함수, 미분, 삼분 탐색            |
| 기하학         | 도형, 거리, 교차 판정  | 피타고라스, CCW, 벡터 내적/외적      |
| 수학적 귀납법  | 점화식 유도, 재귀 성립 | 일반항 추론, 귀납적 정의             |

### 🧩 3. 대표 수학 기법 정리

#### ✅ A. **최대공약수(GCD) / 최소공배수(LCM)**

- 유클리드 알고리즘

```
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)
```

#### ✅ B. **소수 판별 & 에라토스테네스의 체**

- 특정 수가 소수인지 빠르게 판단

```
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# 소수 배열 생성 (1~N)
def sieve(N):
    prime = [True] * (N + 1)
    prime[0] = prime[1] = False
    for i in range(2, int(N ** 0.5) + 1):
        if prime[i]:
            for j in range(i*i, N+1, i):
                prime[j] = False
    return prime
```

#### ✅ C. **조합 계산 (`nCr`)**

- 파스칼 삼각형 기반
- 또는 페르마 소정리 사용한 모듈러 조합 (MOD 소수일 때)

```
# 파스칼 방식
MOD = 10**9+7
def comb(n, r):
    if r == 0 or r == n:
        return 1
    return (comb(n-1, r-1) + comb(n-1, r)) % MOD
```

#### ✅ D. **모듈러 산술 (mod 연산)**

| 법칙                                  | 설명                        |
| ------------------------------------- | --------------------------- |
| (a + b) % m = ((a % m) + (b % m)) % m | 덧셈                        |
| (a × b) % m = ((a % m) × (b % m)) % m | 곱셈                        |
| aᵇ % m                                | 거듭제곱: 반복 제곱 사용    |
| a⁻¹ ≡ a^(m-2) mod m                   | 모듈러 역원 (m이 소수일 때) |

```
def mod_pow(a, b, m):
    result = 1
    a %= m
    while b > 0:
        if b % 2:
            result = result * a % m
        a = a * a % m
        b //= 2
    return result
```

#### ✅ E. **피타고라스 / 거리 공식**

- 두 점 거리: √((x₂−x₁)² + (y₂−y₁)²)
- 직각삼각형, 원, 접선 등 계산
- 좌표 geometry 문제에서 필수

#### ✅ F. **CCW (Counter Clockwise)**

- 세 점이 **반시계/시계/일직선**인지 판별

```
def ccw(x1, y1, x2, y2, x3, y3):
    return (x2 - x1)*(y3 - y1) - (y2 - y1)*(x3 - x1)
# > 0: 반시계 / < 0: 시계 / = 0: 일직선
```

### 🔢 4. 실전에서 자주 나오는 수학적 테크닉

| 테크닉           | 설명                               |
| ---------------- | ---------------------------------- |
| 시그마 공식      | 1~n 합: `n(n+1)/2`                 |
| 등차수열 합      | `n(a1 + an)/2`                     |
| 규칙 기반 점화식 | 피보나치, 계단 오르기, 분할 문제   |
| 패턴 추론        | 나선형 배열, 달팽이 숫자, 토너먼트 |
| 소수 분해        | n = 2^x * 3^y * ... 형태           |

### 🧪 5. 실전 문제 예시

| 문제 유형         | 예시                                        |
| ----------------- | ------------------------------------------- |
| 소수 판별, 나누기 | “소수인지 판별하라” / “n이 소수로 나뉘는가” |
| 조합 경우의 수    | “n개 중 m개를 고르는 경우의 수를 구하라”    |
| 나머지 연산       | “10^18 mod p 값을 구하라”                   |
| 기하 계산         | “두 직선이 교차하는가?” / “원의 넓이”       |
| 거리 합 최적화    | “거리의 총합이 최소인 위치 구하기”          |
| 분할 문제         | “n개의 사람을 k그룹으로 나누는 방법 수”     |

### 🚨 6. 자주 하는 실수

| 실수               | 원인                                          |
| ------------------ | --------------------------------------------- |
| int 나누기 오류    | `//` 안 쓰고 `/` 써서 float 발생              |
| 나머지 연산 부정확 | 괄호 안 씌움: `(a+b)%m != a%m + b%m`          |
| 시간 초과          | `nCr`을 반복계산 → DP or 팩토리얼 전처리 필요 |
| float 오차         | 실수 비교 X → 오차 허용 (예: EPS = 1e-9)      |

### ✅ 핵심 요약

| 항목             | 요약                                       |
| ---------------- | ------------------------------------------ |
| 필수 도구        | GCD/LCM, 소수, 팩토리얼, mod 연산, 조합론  |
| 자주 나오는 주제 | 나머지 계산, 거리 계산, 경우의 수          |
| 효율적 처리      | 반복 제곱, 모듈러 역원, DP 기반 조합 계산  |
| 실전             | 수학 + 구현 or 최적화와 결합 형태가 대부분 |

## 그래프(Graph Theory)

### ✅ 1. 그래프(Graph)란?

> 정점(Vertex, Node)과 간선(Edge)으로 이루어진 구조로,
>  사물 간의 **관계나 연결**을 표현하는 자료구조.

### 📌 2. 그래프의 분류

| 구분                           | 설명                                           |
| ------------------------------ | ---------------------------------------------- |
| **방향 그래프 (Directed)**     | 간선이 방향을 가짐 (A → B)                     |
| **무방향 그래프 (Undirected)** | 간선이 양방향 (A — B)                          |
| **가중치 그래프 (Weighted)**   | 간선에 비용/가중치 존재                        |
| **희소/밀집 그래프**           | 간선 개수가 적거나 많음 (`E ≪ V²` vs `E ≈ V²`) |
| **연결 그래프**                | 모든 정점이 연결되어 있음                      |
| **비연결 그래프**              | 분리된 부분 그래프 존재                        |

### 🧠 3. 그래프 표현 방식

| 방식        | 특징                             | 코드 예시                   |
| ----------- | -------------------------------- | --------------------------- |
| 인접 행렬   | 2차원 배열, 정점 수 작을 때 유리 | `adj[i][j] = cost`          |
| 인접 리스트 | 리스트 배열, 희소 그래프에 유리  | `adj[i] = [(j, cost), ...]` |
| 간선 리스트 | 모든 간선만 저장                 | `edges = [(u, v, cost)]`    |

### 🔄 4. 그래프 탐색 (Traversal)

#### ✅ 1) DFS (Depth-First Search)

- **재귀 or 스택 기반**, 깊게 들어감
- 그래프 연결성 확인, 사이클 탐지 등에서 활용

```
def dfs(u):
    visited[u] = True
    for v in graph[u]:
        if not visited[v]:
            dfs(v)
```

#### ✅ 2) BFS (Breadth-First Search)

- **큐 기반**, 가까운 노드부터 탐색
- 최단 거리 탐색 (단위 가중치), 탐색 순서 보장

```
from collections import deque
def bfs(start):
    q = deque([start])
    visited[start] = True
    while q:
        u = q.popleft()
        for v in graph[u]:
            if not visited[v]:
                visited[v] = True
                q.append(v)
```

### 🧩 5. 주요 그래프 알고리즘

| 알고리즘                       | 설명                                     |
| ------------------------------ | ---------------------------------------- |
| **DFS/BFS**                    | 기본 탐색, 연결 요소 개수, 미로 찾기 등  |
| **Dijkstra**                   | 가중치 O, 양의 간선, 단일 시작 최단 경로 |
| **Bellman-Ford**               | 음수 간선 가능, 음수 사이클 탐지         |
| **Floyd-Warshall**             | 모든 정점 간 최단 경로 (O(V³))           |
| **Kruskal**                    | 최소 신장 트리 (간선 정렬 + Union-Find)  |
| **Prim**                       | 최소 신장 트리 (우선순위 큐 기반)        |
| **위상 정렬**                  | DAG 정렬 (선후 관계 순서)                |
| **강한 연결 요소 (SCC)**       | Tarjan, Kosaraju                         |
| **Union-Find (DSU)**           | 집합 분리/병합, 사이클 탐지              |
| **최대 유량 / 최소 비용 유량** | Ford-Fulkerson, Edmonds-Karp, Dinic      |

### 🔍 6. 그래프 문제에서 자주 보는 키워드

| 키워드            | 의미                                |
| ----------------- | ----------------------------------- |
| 경로(Path)        | 정점을 지나가는 순서                |
| 싸이클(Cycle)     | 시작점 = 도착점                     |
| 트리(Tree)        | 사이클 없는 연결 그래프             |
| 연결 요소         | 연결된 정점들의 덩어리 (component)  |
| 인접 정점         | 간선으로 직접 연결된 정점           |
| 진입차수/진출차수 | in-degree, out-degree (위상 정렬용) |

### 📚 7. 실전 문제 유형

| 유형             | 예시 문제              |
| ---------------- | ---------------------- |
| 미로 탐색        | BFS (최단 거리)        |
| 친구 관계 탐색   | DFS (연결 요소)        |
| 최단 거리        | Dijkstra, Bellman-Ford |
| MST 구성         | Kruskal, Prim          |
| 작업 순서 정하기 | 위상 정렬              |
| 유량 문제        | 최대 유량, 최소 컷     |
| 회로/연결 여부   | Union-Find, DFS 사이클 |

### 🚨 8. 실수 주의 포인트

| 실수 유형                   | 설명                              |
| --------------------------- | --------------------------------- |
| 방향/무방향 혼동            | 간선 넣는 방식에 따라 오류 발생   |
| 방문 체크 누락              | 무한 루프 or 중복 처리            |
| 인접 리스트/행렬 혼동       | 표현 방식에 따라 시간 복잡도 다름 |
| 그래프 범위 초과            | 인덱스 범위 체크 필수             |
| 음수 간선에서 Dijkstra 사용 | 반드시 Bellman-Ford 써야 함       |

### ✅ 핵심 요약

| 항목          | 내용                                 |
| ------------- | ------------------------------------ |
| 구조          | 정점(Vertex), 간선(Edge)             |
| 표현          | 인접 리스트, 인접 행렬, 간선 리스트  |
| 탐색          | DFS, BFS                             |
| 문제 유형     | 경로 찾기, 연결성, MST, 위상 정렬 등 |
| 고급 알고리즘 | SCC, 유량, 강결합 요소 등            |

## DP + Bitmask, DP + 트리 등 복합 유형

### ✅ 1. 개요: 복합 DP 문제란?

> 기본적인 동적 계획법(DP)에 **다른 자료구조/개념**을 결합해서
>  **상태 공간을 더 정밀하게 설계**하고, **복잡한 문제를 해결**하는 전략.

대표 조합:

| 유형           | 결합 대상                      | 예시                        |
| -------------- | ------------------------------ | --------------------------- |
| DP + Bitmask   | 부분집합 표현                  | 외판원(TSP), 최소 경로      |
| DP + Tree      | 트리 구조 위에서의 상태 전이   | 트리 위의 DP (DFS + memo)   |
| DP + 그리디    | 전처리 또는 마무리 조건 최적화 | 최소 동전 개수 문제         |
| DP + 이분 탐색 | LIS, 조건 범위 최적화          | O(N log N) LIS              |
| DP + 최적화    | Knuth, Convex Hull Trick       | 행렬 곱 최적화, 조각 나누기 |

### 🧠 2. DP + Bitmask

#### ✅ 언제 사용?

- **집합의 상태**를 표현해야 할 때 (특히 선택 여부)
- **최대 20개 이하 원소**의 **선택 조합**을 효율적으로 표현
  - 2ⁿ개의 상태 → 각 상태는 비트로 표현 가능

#### 🔷 외판원 문제 (TSP, Traveling Salesman Problem)

> 모든 도시를 한 번씩 방문하고 최소 비용으로 되돌아오기

##### ✔ 상태 정의

```
dp[mask][i] = 
    현재까지 방문한 도시 집합 = mask,
    마지막 방문 도시 = i 일 때의 최소 비용
```

##### ✔ 전이 식

```
for mask in range(1 << n):
    for u in range(n):
        if not (mask & (1 << u)):
            continue
        for v in range(n):
            if mask & (1 << v):
                continue
            new_mask = mask | (1 << v)
            dp[new_mask][v] = min(dp[new_mask][v], dp[mask][u] + cost[u][v])
```

##### ✔ 시간복잡도:

- `O(n² * 2ⁿ)`

#### 🔷 부분집합 최소 비용, 스위치 문제, 선물 조합 문제 등에도 Bitmask DP 사용됨

### 🌲 3. DP + 트리

#### ✅ 언제 사용?

- 트리 구조(사이클 없음)에서의 **최적화 문제**
- 부모 → 자식 또는 자식 → 부모로 **전이관계가 존재**

#### 🔷 대표 패턴: **DFS + Memoization**

```
def dfs(u, parent):
    for v in tree[u]:
        if v == parent:
            continue
        dfs(v, u)
        dp[u] = combine(dp[u], dp[v])
```

#### 🔷 예시 1: 트리 위에서 독립 집합

> **인접한 노드끼리는 선택 못 함**
>  최대 독립된 노드 선택 개수

##### ✔ 상태 정의:

- `dp[u][0]`: u를 선택하지 않은 경우
- `dp[u][1]`: u를 선택한 경우

##### ✔ 전이식:

```
for child in tree[u]:
    if child == parent:
        continue
    dfs(child, u)
    dp[u][0] += max(dp[child][0], dp[child][1])
    dp[u][1] += dp[child][0]
```

#### 🔷 예시 2: 서브트리에서의 최대 합, 최대 길이, 특정 조건 만족 등

### 🔺 4. 기타 복합 유형

#### ✅ DP + 이분 탐색

- 대표: **최장 증가 부분 수열 (LIS)**
- 기본 DP: `O(N²)` → **이분 탐색 결합 시 `O(N log N)`**

```
import bisect
LIS = []
for x in A:
    idx = bisect.bisect_left(LIS, x)
    if idx == len(LIS):
        LIS.append(x)
    else:
        LIS[idx] = x
```

#### ✅ DP + 그리디

- 상태 전이를 그리디하게 하면 될 때
- ex: 동전 교환, 구간 선택 문제 등

#### ✅ DP + Convex Hull Trick (CHT)

- 직선 중에서 x에 대해 최소값/최댓값을 구해야 하는 DP
- 예: `dp[i] = min(dp[j] + cost[j][i])` (단, cost가 볼록/오목 조건 만족 시)
- 고급 알고리즘 대회에서 자주 나옴

### 🚨 5. 자주 하는 실수

| 실수                            | 설명                                         |
| ------------------------------- | -------------------------------------------- |
| 비트마스크 → 잘못된 상태 인코딩 | AND/OR 혼동, 방문 상태 누락                  |
| 트리 DP → 부모-자식 혼동        | 역방향 탐색 시 visited 또는 parent 체크 누락 |
| 시간 초과                       | `2ⁿ` 상태에 `n` 루프 → n > 20이면 위험       |
| 중복 계산                       | 메모이제이션 없이 재귀 반복 발생             |

### ✅ 핵심 요약

| 조합           | 사용 예시                      | 시간복잡도          |
| -------------- | ------------------------------ | ------------------- |
| DP + Bitmask   | TSP, 조합 최소비용, 상태집합   | `O(2ⁿ·n)`           |
| DP + Tree      | 트리 위 최적화, 독립 집합      | `O(N)`              |
| DP + 이분 탐색 | LIS, 정렬된 상태에서 최적 선택 | `O(N log N)`        |
| DP + 그리디    | 동전 교환, 작업 선택 등        | 조건 만족 시 `O(N)` |
| DP + CHT       | 점화식이 볼록/오목 형태        | `O(N log N)` ~      |