# 3. ê³ ê¸‰ ìë£Œêµ¬ì¡° ë° ì•Œê³ ë¦¬ì¦˜

# 3.1 ê³ ê¸‰ íŠ¸ë¦¬ êµ¬ì¡°

## Splay Tree

### ğŸ“Œ ê°œë… ì •ì˜

**Splay Tree**ëŠ” **ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST)**ì˜ ì¼ì¢…ìœ¼ë¡œ, **ì‚½ì…/ì‚­ì œ/íƒìƒ‰ ì´í›„ë§ˆë‹¤ í•´ë‹¹ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ ëŒì–´ì˜¬ë¦¬ëŠ” íšŒì „ ì—°ì‚°(splaying)ì„ ìˆ˜í–‰í•˜ëŠ” íŠ¸ë¦¬**ì´ë‹¤.

> ìì£¼ ì ‘ê·¼ë˜ëŠ” ë…¸ë“œë¥¼ ë£¨íŠ¸ì— ê°€ê¹ê²Œ ìœ ì§€í•˜ì—¬, ì „ì²´ íŠ¸ë¦¬ì˜ ì ‘ê·¼ ì‹œê°„ í‰ê· ì„ ìµœì í™”í•œë‹¤.

### ğŸ§  í•µì‹¬ ê°œë…: Splaying

- íŠ¹ì • ë…¸ë“œì— ì ‘ê·¼ í›„, í•´ë‹¹ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ ì˜¬ë¦¬ëŠ” ê³¼ì •
- **BST ì„±ì§ˆ ìœ ì§€ + ìê°€ ì¡°ì •**
- **3ê°€ì§€ íšŒì „ ìœ í˜•** ì‚¬ìš©: Zig, Zig-Zig, Zig-Zag

### ğŸ” íšŒì „(Rotation) íŒ¨í„´

#### 1ï¸âƒ£ Zig (Single Rotation)

> ë¶€ëª¨ê°€ ë£¨íŠ¸ì¸ ê²½ìš°

```
        x
       /
      y       â†’       y
                x
```

#### 2ï¸âƒ£ Zig-Zig (Double Rotation)

> x â†’ y â†’ z í˜•íƒœë¡œ ì—°ì†ëœ ì™¼ìª½ or ì˜¤ë¥¸ìª½ ìì‹

```
        z
       /
      y
     /
    x        â†’        x
                   \
                    y
                     \
                      z
```

#### 3ï¸âƒ£ Zig-Zag (Double Rotation)

> xê°€ yì˜ ì˜¤ë¥¸ìª½ ìì‹, yëŠ” zì˜ ì™¼ìª½ ìì‹ (ë˜ëŠ” ë°˜ëŒ€)

```
        z
       /
      y
       \
        x       â†’        x
                      /     \
                     y       z
```

### ğŸ“Š ì—°ì‚° ì„±ëŠ¥ ë¶„ì„

| ì—°ì‚° | ì‹œê°„ ë³µì¡ë„ (í‰ê· ) | ìµœì•… ì‹œê°„ ë³µì¡ë„ |
| ---- | ------------------ | ---------------- |
| ì‚½ì… | O(log n)           | O(n)             |
| ì‚­ì œ | O(log n)           | O(n)             |
| íƒìƒ‰ | O(log n)           | O(n)             |

âœ… í•˜ì§€ë§Œ **ëª¨ë“  ì—°ì‚° í›„ ë£¨íŠ¸ë¡œ ì´ë™ì‹œí‚¤ê¸° ë•Œë¬¸ì—, ìì£¼ ì“°ì´ëŠ” ë…¸ë“œì— ëŒ€í•´ ì ‘ê·¼ ì†ë„ê°€ í–¥ìƒë¨ (working set íš¨ê³¼)**
 â¡ï¸ **ì „ì²´ ì—°ì‚°ì— ëŒ€í•œ ì‹œê°„ë³µì¡ë„ëŠ” O(m log n)** (më²ˆ ì—°ì‚°, nê°œì˜ ë…¸ë“œ)

### ğŸ”§ C ìŠ¤íƒ€ì¼ ë…¸ë“œ êµ¬ì¡°

```
typedef struct Node {
    int key;
    struct Node* left;
    struct Node* right;
} Node;
```

### âš™ï¸ ì‚½ì… ì—°ì‚°

1. ì¼ë°˜ BST ë°©ì‹ìœ¼ë¡œ ì‚½ì…
2. ì‚½ì…ëœ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ **Splay**

### âš™ï¸ íƒìƒ‰ ì—°ì‚°

1. ì°¾ê³ ì í•˜ëŠ” ë…¸ë“œë¥¼ BST íƒìƒ‰
2. íƒìƒ‰í•œ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ **Splay**

> ğŸ’¡ íƒìƒ‰ ì‹¤íŒ¨ ì‹œ, ë§ˆì§€ë§‰ íƒìƒ‰ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ ì˜¬ë¦´ ìˆ˜ ìˆìŒ

### âš™ï¸ ì‚­ì œ ì—°ì‚°

1. ì‚­ì œí•  ë…¸ë“œë¥¼ íƒìƒ‰ í›„ Splay
2. ë£¨íŠ¸ì—ì„œ ì œê±° â†’ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì™€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ë¶„ë¦¬
3. ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ **ìµœëŒ€ ë…¸ë“œë¥¼ Splay** â†’ ë£¨íŠ¸ë¡œ
4. ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì˜¤ë¥¸ìª½ ìì‹ìœ¼ë¡œ ë¶™ì„

### ğŸ§­ Splay Treeì˜ íŠ¹ì§•

| íŠ¹ì§•             | ì„¤ëª…                                       |
| ---------------- | ------------------------------------------ |
| ìê°€ ì¡°ì • íŠ¸ë¦¬   | í•­ìƒ ë£¨íŠ¸ê°€ ìµœê·¼ ì‚¬ìš©ëœ ë…¸ë“œ               |
| ê· í˜• ì¡°ê±´ ì—†ìŒ   | AVLì²˜ëŸ¼ ë†’ì´ ê· í˜•ì„ ìœ ì§€í•˜ì§€ ì•ŠìŒ          |
| ì¤‘ë³µ í—ˆìš© ë¶ˆê°€   | BST ì„±ì§ˆìƒ í‚¤ëŠ” ìœ ì¼                       |
| ë°˜ë³µ ì ‘ê·¼ ìµœì í™” | ìì£¼ ì ‘ê·¼í•˜ëŠ” í‚¤ì— ëŒ€í•´ O(1)ì— ê°€ê¹Œìš´ ì„±ëŠ¥ |
| ê³µê°„ íš¨ìœ¨ ë†’ìŒ   | ê· í˜• íŠ¸ë¦¬ì²˜ëŸ¼ balance factor ì—†ìŒ          |

### âš ï¸ Splay Tree vs AVL/Red-Black Tree

| í•­ëª©             | Splay Tree         | AVL / Red-Black Tree     |
| ---------------- | ------------------ | ------------------------ |
| ê· í˜• ìœ ì§€        | X (ì•”ì‹œì  ìœ ì§€)    | O (ëª…ì‹œì  ìœ ì§€)          |
| ìµœì•… ì‹œê°„ë³µì¡ë„  | O(n)               | O(log n)                 |
| í‰ê·  ì‹œê°„ë³µì¡ë„  | O(log n)           | O(log n)                 |
| êµ¬í˜„ ë³µì¡ë„      | ë‚®ìŒ               | ë†’ìŒ                     |
| ìì£¼ ì ‘ê·¼ ìµœì í™” | O(1) ìˆ˜ì¤€ìœ¼ë¡œ ê°€ëŠ¥ | X                        |
| ë©”ëª¨ë¦¬ ì¶”ê°€ í•„ìš” | ì—†ìŒ               | ìˆìŒ (balance factor ë“±) |

### âœ… ì–¸ì œ Splay Treeë¥¼ ì‚¬ìš©í•˜ë‚˜?

| ìƒí™©                                      | ì´ìœ                     |
| ----------------------------------------- | ----------------------- |
| íŠ¹ì • í‚¤ì— ëŒ€í•œ **ì§‘ì¤‘ì  ì ‘ê·¼**ì´ ì¦ì„ ë•Œ  | ë£¨íŠ¸ë¡œ ìŠ¤í”Œë ˆì´ë¨       |
| ì „ì²´ ë²”ìœ„ë³´ë‹¤ **ì¼ë¶€ë¶„ë§Œ ìì£¼ ì¡°íšŒ**í•  ë•Œ | working-set ìµœì í™”      |
| **ê· í˜• ìœ ì§€ ë¶€í•˜ ì¤„ì´ê³  ì‹¶ì„ ë•Œ**         | AVLë³´ë‹¤ ê°„ë‹¨            |
| ìºì‹œ, í…ìŠ¤íŠ¸ í¸ì§‘ê¸°, í˜ì´ì§€ íˆìŠ¤í† ë¦¬ ë“±   | ì§€ì—­ì„± ê°•í•œ ì‘ì—…ì— ì í•© |

### ğŸ§  ì‘ìš© ì‚¬ë¡€

- í…ìŠ¤íŠ¸ í¸ì§‘ê¸° undo/redo
- ë©”ëª¨ë¦¬ í• ë‹¹ê¸°
- ê°€ìƒ ë©”ëª¨ë¦¬ í˜ì´ì§€ êµì²´
- ë””ìŠ¤í¬ ë¸”ë¡ ìºì‹œ
- ë¬¸ìì—´ ê²€ìƒ‰ (ì ‘ë‘ì‚¬ ë¹ˆë„ ë†’ì€ ê²½ìš°)

### ğŸ’¬ ì¸í„°ë·°ì—ì„œ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ì§ˆë¬¸

- Splay TreeëŠ” ì–´ë–»ê²Œ ê· í˜•ì„ ìœ ì§€í•˜ë‚˜ìš”?
- AVLê³¼ ë¹„êµí–ˆì„ ë•Œì˜ ì¥ì ê³¼ ë‹¨ì ì€?
- Splayingì˜ íŒ¨í„´ì„ ì„¤ëª…í•´ë³´ì„¸ìš”.
- Splay Treeë¥¼ ì“°ë©´ í•­ìƒ ë¹ ë¥¸ê°€ìš”?
- ì¬ê·€ ì•„ë‹Œ iterative êµ¬í˜„ì´ ê°€ëŠ¥í•œê°€ìš”?

### ğŸ“Œ ì •ë¦¬ ìš”ì•½

| íŠ¹ì„±        | ë‚´ìš©                             |
| ----------- | -------------------------------- |
| íŠ¸ë¦¬ ìœ í˜•   | ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST) ê¸°ë°˜        |
| íŠ¹ì§•        | ìì£¼ ì ‘ê·¼í•˜ëŠ” ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ ìŠ¹ê²© |
| íšŒì „ ì¢…ë¥˜   | Zig, Zig-Zig, Zig-Zag            |
| ì‹œê°„ ë³µì¡ë„ | O(log n) í‰ê· , O(n) ìµœì•…         |
| ê°•ì         | locality of reference ìµœì í™”     |
| ë‹¨ì         | ìµœì•… ì¼€ì´ìŠ¤ê°€ ë§ê³  ë³´ì¥ ì—†ìŒ     |
| ë¹„êµ ëŒ€ìƒ   | AVL, Red-Black Tree, Treap       |

## Segment Tree with Lazy Propagation

### ğŸ“Œ 1. Segment Treeë€?

- **ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬**ëŠ” ì£¼ì–´ì§„ ë°°ì—´ì— ëŒ€í•´ **íŠ¹ì • êµ¬ê°„ì˜ ì •ë³´ë¥¼ ë¹ ë¥´ê²Œ ê³„ì‚°í•  ìˆ˜ ìˆëŠ” íŠ¸ë¦¬ ìë£Œêµ¬ì¡°**
- `O(log n)` ì‹œê°„ ë³µì¡ë„ë¡œ **êµ¬ê°„ ì¿¼ë¦¬(query)**ì™€ **ì /êµ¬ê°„ ì—…ë°ì´íŠ¸(update)** ì²˜ë¦¬ ê°€ëŠ¥

```
ì˜ˆ: [2, 1, 5, 3, 4]
- ì¿¼ë¦¬: êµ¬ê°„ [1, 3]ì˜ í•© = 1 + 5 + 3 = 9
- ì¿¼ë¦¬: êµ¬ê°„ [0, 4]ì˜ ìµœëŒ“ê°’
- ì—…ë°ì´íŠ¸: ì¸ë±ìŠ¤ 2ì˜ ê°’ì„ 10ìœ¼ë¡œ ë³€ê²½
```

### ğŸ“¦ 2. ê¸°ë³¸ Segment Tree êµ¬ì¡°

- ë³´í†µ **2n í¬ê¸°ì˜ ë°°ì—´ë¡œ êµ¬í˜„**
- **ë£¨íŠ¸ = ì „ì²´ êµ¬ê°„**, ìì‹ì€ ì™¼ìª½/ì˜¤ë¥¸ìª½ ì ˆë°˜ì„ ì˜ë¯¸
- ë…¸ë“œëŠ” ë‹¤ìŒì„ ì €ì¥:
  - `start`, `end`: êµ¬ê°„ ë²”ìœ„
  - `value`: í•´ë‹¹ êµ¬ê°„ì˜ ì •ë³´ (í•©, ìµœëŒ“ê°’ ë“±)

### ğŸ“‰ ê¸°ë³¸ ì‹œê°„ ë³µì¡ë„

| ì—°ì‚° ìœ í˜•   | ì‹œê°„ ë³µì¡ë„ |
| ----------- | ----------- |
| êµ¬ê°„ ì¿¼ë¦¬   | O(log n)    |
| ì  ì—…ë°ì´íŠ¸ | O(log n)    |
| ì „ì²´ ë¹Œë“œ   | O(n)        |

### âš¡ ë¬¸ì œì : êµ¬ê°„ ì—…ë°ì´íŠ¸ ì‹œ ì„±ëŠ¥ ì €í•˜

ì˜ˆë¥¼ ë“¤ì–´, `[1, 10]` êµ¬ê°„ì— ëª¨ë‘ `+3` í•˜ë ¤ë©´â€¦

- íŠ¸ë¦¬ë¥¼ ì „ë¶€ ë‚´ë ¤ê°€ë©´ì„œ ìì‹ ë…¸ë“œë¥¼ ëª¨ë‘ ìˆ˜ì •í•´ì•¼ í•¨ â†’ **O(n)**

### ğŸ’¡ í•´ê²°ì±…: Lazy Propagation (ì§€ì—° ì—…ë°ì´íŠ¸)

> **í•„ìš”í•  ë•Œë§Œ ì—…ë°ì´íŠ¸** í•˜ì! (ë‚˜ì¤‘ì— ë°€ì–´ë‘ê¸°)

- ë³€ê²½ ìš”ì²­ì´ ë“¤ì–´ì˜¤ë©´, **ë…¸ë“œë¥¼ ì¦‰ì‹œ ìˆ˜ì •í•˜ì§€ ì•Šê³  lazy ë°°ì—´ì— í‘œì‹œ**
- í•´ë‹¹ ë…¸ë“œì— ì ‘ê·¼í•  ë•Œ **ê·¸ì œì•¼ ì ìš©(push-down)**

### ğŸ§  í•µì‹¬ ì•„ì´ë””ì–´ ìš”ì•½

| êµ¬ì„± ìš”ì†Œ  | ì„¤ëª…                                      |
| ---------- | ----------------------------------------- |
| `tree[]`   | êµ¬ê°„ ì •ë³´ë¥¼ ë‹´ëŠ” ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ë°°ì—´       |
| `lazy[]`   | "ì´ êµ¬ê°„ì— ì•„ì§ ë°˜ì˜ ì•ˆ ëœ ì—…ë°ì´íŠ¸" ì €ì¥ |
| `push()`   | ìì‹ ë…¸ë“œë¡œ lazy ê°’ì„ ì „íŒŒ                |
| `update()` | êµ¬ê°„ ì—…ë°ì´íŠ¸ ìš”ì²­ ì‹œ lazyì—ë§Œ ê¸°ë¡       |
| `query()`  | ì¿¼ë¦¬ ì‹œ lazy ê°’ ë¨¼ì € ë°˜ì˜í•˜ê³  ì²˜ë¦¬        |

### ğŸ”§ 3. êµ¬í˜„ (C++ ë²„ì „ ì˜ˆì‹œ: êµ¬ê°„ í•© íŠ¸ë¦¬)

```
const int MAX = 1 << 18;
int tree[MAX * 2];
int lazy[MAX * 2];

// ë‚´ë¶€ ë…¸ë“œì— lazy ê°’ì„ ìì‹ìœ¼ë¡œ ì „íŒŒ
void push(int node, int l, int r) {
    if (lazy[node] != 0) {
        tree[node] += (r - l + 1) * lazy[node];
        if (l != r) {
            lazy[node * 2] += lazy[node];
            lazy[node * 2 + 1] += lazy[node];
        }
        lazy[node] = 0;
    }
}

// êµ¬ê°„ ì—…ë°ì´íŠ¸: [start, end] êµ¬ê°„ì— valì„ ë”í•˜ê¸°
void update(int node, int l, int r, int start, int end, int val) {
    push(node, l, r);
    if (r < start || end < l) return; // ì „í˜€ ì•ˆ ê²¹ì¹¨
    if (start <= l && r <= end) {     // ì™„ì „íˆ í¬í•¨
        lazy[node] += val;
        push(node, l, r);
        return;
    }
    int mid = (l + r) / 2;
    update(node * 2, l, mid, start, end, val);
    update(node * 2 + 1, mid + 1, r, start, end, val);
    tree[node] = tree[node * 2] + tree[node * 2 + 1];
}

// êµ¬ê°„ ì¿¼ë¦¬: [start, end] êµ¬ê°„ì˜ í•©
int query(int node, int l, int r, int start, int end) {
    push(node, l, r);
    if (r < start || end < l) return 0;
    if (start <= l && r <= end) return tree[node];
    int mid = (l + r) / 2;
    return query(node * 2, l, mid, start, end) +
           query(node * 2 + 1, mid + 1, r, start, end);
}
```

> ìœ„ëŠ” ë°°ì—´ [1, N]ì„ ëŒ€ìƒìœ¼ë¡œ segment tree + lazy propagationì„ ì‚¬ìš©í•˜ëŠ” êµ¬ê°„ í•© ì˜ˆì‹œ.

### ğŸ“Š ì‹œê°„ ë³µì¡ë„ (Lazy ì ìš© í›„)

| ì—°ì‚°          | ì‹œê°„ ë³µì¡ë„ |
| ------------- | ----------- |
| êµ¬ê°„ ì¿¼ë¦¬     | O(log n)    |
| êµ¬ê°„ ì—…ë°ì´íŠ¸ | O(log n)    |
| ì „ì²´ ì´ˆê¸°í™”   | O(n)        |

### âœ… Lazy Propagationì´ í•„ìš”í•œ ìƒí™©

| ë¬¸ì œ ìƒí™©                               | Lazy í•„ìš” ì—¬ë¶€                        |
| --------------------------------------- | ------------------------------------- |
| **ì  ì—…ë°ì´íŠ¸ë§Œ ìˆëŠ” ë¬¸ì œ**             | âŒ ë¶ˆí•„ìš” (ê¸°ë³¸ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ suffice) |
| **êµ¬ê°„ ì—…ë°ì´íŠ¸ + êµ¬ê°„ ì¿¼ë¦¬**           | âœ… í•„ìˆ˜                                |
| **ì¿¼ë¦¬ ìˆ˜ â‰« ë°°ì—´ í¬ê¸° (ë§ì€ ì—…ë°ì´íŠ¸)** | âœ… ë§¤ìš° ìœ ë¦¬                           |

### ğŸ§  í™•ì¥ ê°€ëŠ¥í•œ ì—°ì‚°

Lazy Propagationì€ ë‹¤ìŒê³¼ ê°™ì€ ì—°ì‚°ì—ì„œë„ ì ìš© ê°€ëŠ¥:

- êµ¬ê°„ í•©, êµ¬ê°„ ìµœì†Ÿê°’, êµ¬ê°„ ìµœëŒ“ê°’
- êµ¬ê°„ ê³±ì…ˆ
- **êµ¬ê°„ ì „ì²´ ì¹˜í™˜ (`arr[i] = X`)** â† lazy ê°’ 1ê°œê°€ ì•„ë‹Œ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ í™•ì¥ í•„ìš”
- ë¹„íŠ¸ ë§ˆìŠ¤í‚¹, XOR, boolean ì—°ì‚°ë„ ê°€ëŠ¥

### ğŸ’¡ ì‹¤ì „ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ì˜ˆì‹œ

| ë¬¸ì œ ì´ë¦„                           | í”Œë«í¼    | ê°œë…                  |
| ----------------------------------- | --------- | --------------------- |
| êµ¬ê°„ í•© êµ¬í•˜ê¸° 2                    | BOJ 10999 | lazy segment tree     |
| ìˆ˜ì—´ê³¼ ì¿¼ë¦¬ 17                      | BOJ 14428 | min segment tree      |
| Count of Smaller Numbers After Self | Leetcode  | segment + compression |
| Range Addition                      | Leetcode  | êµ¬ê°„ update + lazy    |

### ğŸ’¬ ì¸í„°ë·°ì—ì„œ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ì§ˆë¬¸

- Lazy Propagationì´ í•„ìš”í•œ ì´ìœ ëŠ”?
- ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ì™€ íœìœ… íŠ¸ë¦¬ ì°¨ì´ì ì€?
- êµ¬ê°„ ì „ì²´ ê°’ì„ ì¹˜í™˜í•˜ëŠ” ê²½ìš° ì–´ë–»ê²Œ lazyë¥¼ í™•ì¥í•  ê²ƒì¸ê°€?
- ë™ì  ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ëŠ” ë¬´ì—‡ì´ë©° ì–¸ì œ ì“°ëŠ”ê°€?

### ğŸ“Œ ìš”ì•½ ì •ë¦¬

| í•­ëª©             | ë‚´ìš©                                                     |
| ---------------- | -------------------------------------------------------- |
| êµ¬ì¡°             | ì™„ì „ ì´ì§„ íŠ¸ë¦¬ (ë°°ì—´ë¡œ í‘œí˜„)                             |
| ìš©ë„             | êµ¬ê°„ ì •ë³´ì˜ ë¹ ë¥¸ ì¿¼ë¦¬ì™€ ì—…ë°ì´íŠ¸                         |
| Lazy Propagation | ì§€ì—° ì—…ë°ì´íŠ¸ë¥¼ í†µí•´ ì„±ëŠ¥ í–¥ìƒ                           |
| í•µì‹¬ ì•„ì´ë””ì–´    | í•„ìš”í•  ë•Œë§Œ ì—…ë°ì´íŠ¸, ì•ˆ ì“°ë©´ O(n)                       |
| ì‹œê°„ë³µì¡ë„       | O(log n) per query/update                                |
| ì‘ìš© ë¶„ì•¼        | ê²½ìŸ í”„ë¡œê·¸ë˜ë°, DB ì—…ë°ì´íŠ¸, UI ì—…ë°ì´íŠ¸, ì‹œë®¬ë ˆì´ì…˜ ë“± |

## Treap

### ğŸ§  ê¸°ë³¸ ê°œë…

**ì£¼ì†Œì§€ì • ë°©ì‹(Addressing Mode)**ì€ ëª…ë ¹ì–´ ë‚´ ì˜¤í¼ëœë“œê°€ ì‹¤ì œ ë°ì´í„°ë¥¼ ì–´ë–»ê²Œ ì°¸ì¡°í•˜ëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë°©ì‹ì´ì•¼.

> ê°™ì€ ëª…ë ¹ì–´ë¼ë„ ì£¼ì†Œì§€ì • ë°©ì‹ì— ë”°ë¼ **ë‹¤ë¥¸ ìœ„ì¹˜ì˜ ë°ì´í„°**ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì–´.

### ğŸ”© ì£¼ì†Œì§€ì • ë°©ì‹ ì¢…ë¥˜ ë° ì„¤ëª…

| ë°©ì‹                                                  | ì„¤ëª…                                 | ì˜ˆì‹œ                                  |
| ----------------------------------------------------- | ------------------------------------ | ------------------------------------- |
| **1. ì¦‰ì‹œ (Immediate)**                               | ì˜¤í¼ëœë“œê°€ ê°’ ê·¸ ìì²´                | `MOV R1, #5` â†’ R1 â† 5                 |
| **2. ë ˆì§€ìŠ¤í„° (Register)**                            | ì˜¤í¼ëœë“œê°€ ë ˆì§€ìŠ¤í„°                  | `ADD R1, R2` â†’ R1 â† R1 + R2           |
| **3. ì§ì ‘ (Direct)**                                  | ëª…ë ¹ì–´ì— ë©”ëª¨ë¦¬ ì£¼ì†Œê°€ í¬í•¨          | `MOV R1, [1000h]` â†’ R1 â† MEM[1000h]   |
| **4. ê°„ì ‘ (Indirect)**                                | ë ˆì§€ìŠ¤í„°ê°€ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚´             | `MOV R1, [R2]` â†’ R1 â† MEM[R2]         |
| **5. ë ˆì§€ìŠ¤í„° ê°„ì ‘ + ì˜¤í”„ì…‹**                         | ë² ì´ìŠ¤ + ë³€ìœ„ (offset)               | `MOV R1, [R2 + 4]`                    |
| **6. ì¸ë±ìŠ¤ (Indexed)**                               | ë°°ì—´ ì ‘ê·¼ìš© (ë² ì´ìŠ¤ + ì¸ë±ìŠ¤ * í¬ê¸°) | `MOV R1, [R2 + R3]`                   |
| **7. ìƒëŒ€ (PC-relative)**                             | í˜„ì¬ ìœ„ì¹˜ ê¸°ì¤€ ì£¼ì†Œ                  | `JMP PC+8`                            |
| **8. ìë™ ì¦ê°€/ê°ì†Œ (Auto-increment/Auto-decrement)** | ì ‘ê·¼ í›„ ì£¼ì†Œ ë³€í™”                    | `MOV R1, [R2++]`                      |
| **9. ìŠ¤íƒ ì£¼ì†Œì§€ì • (Implicit via SP)**                | PUSH/POPì²˜ëŸ¼ ì•”ë¬µì ìœ¼ë¡œ SP ì‚¬ìš©      | `PUSH R1` â†’ SP â† SP - 4; MEM[SP] â† R1 |

### ğŸ§ª ê° ë°©ì‹ ë¹„êµ ì˜ˆì‹œ

| ì–´ì…ˆë¸”ë¦¬ ëª…ë ¹       | ì£¼ì†Œì§€ì • ë°©ì‹   | ì˜ë¯¸                      |
| ------------------- | --------------- | ------------------------- |
| `MOV R1, #5`        | ì¦‰ì‹œ            | R1 â† 5                    |
| `MOV R1, R2`        | ë ˆì§€ìŠ¤í„°        | R1 â† R2                   |
| `MOV R1, [1000h]`   | ì§ì ‘            | R1 â† MEM[1000h]           |
| `MOV R1, [R2]`      | ê°„ì ‘            | R1 â† MEM[R2]              |
| `MOV R1, [R2 + 8]`  | ë² ì´ìŠ¤ + ì˜¤í”„ì…‹ | R1 â† MEM[R2+8]            |
| `MOV R1, [R2 + R3]` | ì¸ë±ìŠ¤          | R1 â† MEM[R2 + R3]         |
| `JMP label`         | ìƒëŒ€            | PC â† PC + offset          |
| `LDR R1, [R2], #4`  | ìë™ ì¦ê°€       | R1 â† MEM[R2], R2 â† R2 + 4 |

### ğŸ“ ì‹¤ì œ ISAë³„ ì£¼ì†Œì§€ì • ë°©ì‹ ìš”ì•½

| ISA        | ì§€ì› ë°©ì‹                     | ë¹„ê³                        |
| ---------- | ----------------------------- | -------------------------- |
| **x86**    | ê±°ì˜ ëª¨ë“  ë°©ì‹ ì§€ì›           | ë§¤ìš° ìœ ì—°í•˜ë‚˜ ë³µì¡         |
| **ARM**    | ì¦‰ì‹œ, ê°„ì ‘, ì˜¤í”„ì…‹, PC ìƒëŒ€   | LDR/STR ê³„ì—´ì—ì„œ ë¶„ë¦¬ ì§€ì› |
| **MIPS**   | ì œí•œëœ ë°©ì‹ (Base + Offsetë§Œ) | Load/Store ì „ìš© êµ¬ì¡°       |
| **RISC-V** | Base+Offset, PC-relative      | ë‹¨ìˆœí•˜ê³  ì •í˜•í™”ëœ êµ¬ì¡°     |

### ğŸ“Š ì‹œê°ì  ë¹„êµ ì˜ˆì‹œ

```
ëª…ë ¹ì–´:   MOV R1, [R2 + 4]
ì„¤ëª…:     R2ëŠ” ê¸°ì¤€ ì£¼ì†Œ (Base), 4ëŠ” ì˜¤í”„ì…‹
ì‹¤ì œ ë™ì‘: R1 â† ë©”ëª¨ë¦¬ ì£¼ì†Œ (R2 + 4)ì˜ ê°’
```

### ğŸ§  ì£¼ì†Œì§€ì • ë°©ì‹ ì„ íƒ ê¸°ì¤€

| ëª©ì               | ì¶”ì²œ ë°©ì‹                | ì´ìœ                  |
| ----------------- | ------------------------ | -------------------- |
| ìƒìˆ˜ ì„¤ì •         | Immediate                | ë¹ ë¥´ê³  ë©”ëª¨ë¦¬ ë¶ˆí•„ìš” |
| ë³€ìˆ˜ ê°„ ì—°ì‚°      | Register                 | ê³ ì†                 |
| êµ¬ì¡°ì²´/ë°°ì—´ ì ‘ê·¼  | Base + Offset            | í•„ë“œ ì ‘ê·¼ì— ì í•©     |
| í•¨ìˆ˜ í…Œì´ë¸”       | ê°„ì ‘                     | ìœ ì—°í•œ ì œì–´ íë¦„     |
| ë£¨í”„ ë‚´ ë°°ì—´ ìˆœíšŒ | Indexed / Auto-increment | ë°˜ë³µ ì ‘ê·¼ì— ìµœì      |

### ğŸ’¬ ê³ ê¸‰ í™œìš©

| ê¸°ë²•                 | ì‚¬ìš© ì˜ˆ                                |
| -------------------- | -------------------------------------- |
| **PC-relative**      | ì‹¤í–‰ ìœ„ì¹˜ ë…ë¦½ ì½”ë“œ (PIC, shared lib)  |
| **Auto-increment**   | ë¬¸ìì—´ ë³µì‚¬, ë°°ì—´ ìˆœíšŒ                 |
| **Indirect + Index** | 2ì°¨ì› ë°°ì—´, ê°€ìƒ í…Œì´ë¸” ì ‘ê·¼           |
| **SP-relative**      | í•¨ìˆ˜ ë¡œì»¬ ë³€ìˆ˜ ì°¸ì¡° (Stack Frame ê¸°ë°˜) |

### ğŸ“Œ ìš”ì•½ ì •ë¦¬

- ì£¼ì†Œì§€ì • ë°©ì‹ì€ **ì˜¤í¼ëœë“œ(í”¼ì—°ì‚°ì)ì˜ ìœ„ì¹˜ë¥¼ í•´ì„í•˜ëŠ” ë°©ë²•**ì´ë‹¤.
- ì¦‰ì‹œ, ë ˆì§€ìŠ¤í„°, ì§ì ‘, ê°„ì ‘, ë² ì´ìŠ¤+ì˜¤í”„ì…‹, ì¸ë±ìŠ¤, ìƒëŒ€, ìë™ ì¦ê°€ ë“± ë‹¤ì–‘í•œ ë°©ì‹ì´ ì¡´ì¬í•˜ê³ , ëª©ì ì— ë”°ë¼ ì‚¬ìš©ëœë‹¤.
- í˜„ëŒ€ ISAëŠ” ì„±ëŠ¥, ì „ë ¥, ì½”ë“œ í¬ê¸° ë“±ì„ ê³ ë ¤í•´ ì£¼ì†Œì§€ì • ë°©ì‹ì„ ì¡°í•©ì ìœ¼ë¡œ ì±„íƒí•˜ê³  ìˆìœ¼ë©°, ì´ êµ¬ì¡°ëŠ” **ëª…ë ¹ì–´ íš¨ìœ¨ì„±ì˜ í•µì‹¬ ìš”ì†Œ**ë‹¤.

## B-Tree, B+ Tree (ë°ì´í„°ë² ì´ìŠ¤ ìš©ë„)

> âœ… ë°ì´í„°ë² ì´ìŠ¤ì™€ íŒŒì¼ ì‹œìŠ¤í…œ ì¸ë±ìŠ¤ì˜ í‘œì¤€ êµ¬ì¡°

### ğŸ“Œ 1. B-Treeë€?

**B-Tree**ëŠ” ë‹¤ì§„ íŠ¸ë¦¬(M-ary Tree)ë¡œ,
 ëª¨ë“  ë¦¬í”„ ë…¸ë“œê°€ **ë™ì¼í•œ ê¹Šì´**ì— ìˆê³ ,
 ê° ë…¸ë“œëŠ” **ì—¬ëŸ¬ ê°œì˜ í‚¤ì™€ ìì‹ í¬ì¸í„°ë¥¼ ê°€ì§**.

> ë””ìŠ¤í¬ ì ‘ê·¼ íšŸìˆ˜ë¥¼ ìµœì†Œí™”í•˜ë„ë¡ ì„¤ê³„ëœ **ê· í˜• ê²€ìƒ‰ íŠ¸ë¦¬**

### ğŸ§  ì£¼ìš” íŠ¹ì§•

| í•­ëª©                | ì„¤ëª…                                          |
| ------------------- | --------------------------------------------- |
| ê· í˜• ìœ ì§€           | ì‚½ì…/ì‚­ì œ í›„ì—ë„ í•­ìƒ ê· í˜• ìœ ì§€ (ë†’ì´ ìœ ì§€ë¨) |
| ë‹¤ì§„ êµ¬ì¡°           | ìì‹ ìˆ˜ê°€ ë§ì•„ í•œ ë…¸ë“œì— ì—¬ëŸ¬ í‚¤ ì €ì¥ ê°€ëŠ¥    |
| ë…¸ë“œ í¬ê¸°           | ë””ìŠ¤í¬ ë¸”ë¡ í¬ê¸°ì— ë§ì¶° ì„¤ì • (I/O ìµœì†Œí™”)     |
| ì •ë ¬ëœ í‚¤ ìœ ì§€      | ì¤‘ìœ„ ìˆœíšŒ ì‹œ ì˜¤ë¦„ì°¨ìˆœ ì¶œë ¥ ê°€ëŠ¥               |
| ì‚½ì…/ì‚­ì œ/íƒìƒ‰ ì„±ëŠ¥ | O(log n) (ê¸°ìˆ˜ mì— ë”°ë¼ ë” ë¹ ë¦„)              |

### ğŸ“Œ 2. B-Treeì˜ êµ¬ì¡° (ê°„ë‹¨ ì˜ˆì‹œ)

```
ì˜ˆì‹œ: B-Tree of order 3 (ìµœëŒ€ 2í‚¤, ìµœëŒ€ 3ìì‹)

          [17]
        /     \
     [3, 8]   [20, 25]

ê° ë…¸ë“œëŠ” ë‹¤ìŒì„ ê°€ì§:
- ìµœëŒ€ m-1 ê°œì˜ í‚¤
- ìµœëŒ€ m ê°œì˜ ìì‹
- í‚¤ì™€ ìì‹ ì‚¬ì´ ê´€ê³„: [K1] â†’ < K1, [K2] â†’ < K2, ...
```

### ğŸ”„ B-Tree ì—°ì‚° (ì‚½ì…/ì‚­ì œ ì‹œ)

- ì‚½ì… ì‹œ: ë…¸ë“œê°€ ê°€ë“ ì°¨ë©´ **ë¶„í• (split)**
- ì‚­ì œ ì‹œ: ë…¸ë“œê°€ ë„ˆë¬´ ì‘ì•„ì§€ë©´ **ë³‘í•© ë˜ëŠ” í‚¤ ì´ë™(rebalance)** ìˆ˜í–‰
- í•­ìƒ ë¦¬í”„ê¹Œì§€ ë„ë‹¬í•´ì•¼ ì—°ì‚°ì´ ëë‚¨

### ğŸ“Œ 3. B+ Treeë€?

**B+ Tree**ëŠ” B-Treeì˜ ë³€í˜•ìœ¼ë¡œ,
 ëª¨ë“  **ë°ì´í„°(ê°’)ëŠ” ë¦¬í”„ ë…¸ë“œì—ë§Œ ì¡´ì¬**,
 ë‚´ë¶€ ë…¸ë“œëŠ” **ê²½ë¡œ íƒìƒ‰ìš© í‚¤ë§Œ ë³´ê´€**í•œë‹¤.

### ğŸ’¡ í•µì‹¬ ì°¨ì´ì 

| í•­ëª©             | B-Tree           | B+ Tree                                         |
| ---------------- | ---------------- | ----------------------------------------------- |
| ë°ì´í„° ì €ì¥ ìœ„ì¹˜ | ëª¨ë“  ë…¸ë“œì— ìˆìŒ | **ë¦¬í”„ ë…¸ë“œì—ë§Œ ìˆìŒ**                          |
| ë²”ìœ„ ì¿¼ë¦¬ íš¨ìœ¨   | ë¹„íš¨ìœ¨ì          | **ë¦¬í”„ ë…¸ë“œê°€ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì²˜ëŸ¼ ì—°ê²°ë¨ â†’ íš¨ìœ¨ì ** |
| ë¦¬í”„ ë…¸ë“œ ì—°ê²°   | ì—†ìŒ             | **ìˆìŒ (â†’ ë²”ìœ„ ì¡°íšŒ ìµœì í™”)**                   |
| ë‚´ë¶€ ë…¸ë“œ ì—­í•    | í‚¤ + ê°’ í¬í•¨     | **í‚¤ë§Œ ì¡´ì¬ (ì¸ë±ì‹± ì—­í• ë§Œ)**                   |

### ğŸ§  B+ Treeì˜ êµ¬ì¡° (ì˜ˆì‹œ)

```
              [17, 25]
              /      \
          [5, 8, 12] [17, 20, 24]

ë¦¬í”„ ë…¸ë“œ:
[5] â†’ [8] â†’ [12] â†’ [17] â†’ [20] â†’ [24]
(â† ëª¨ë“  ì‹¤ì œ ë°ì´í„°ëŠ” ì—¬ê¸°ë§Œ ì €ì¥)
```

### â±ï¸ ì„±ëŠ¥ ë¹„êµ ìš”ì•½

| ì—°ì‚°          | B-Tree   | B+ Tree                             |
| ------------- | -------- | ----------------------------------- |
| ê²€ìƒ‰          | O(log n) | O(log n)                            |
| ì‚½ì…/ì‚­ì œ     | O(log n) | O(log n)                            |
| **ë²”ìœ„ ê²€ìƒ‰** | ëŠë¦¼     | **ë¹ ë¦„ (ë¦¬í”„ ì—°ê²°)**                |
| I/O ì ì¤‘ë¥     | ì¤‘ê°„     | **ë†’ìŒ** (ë‚´ë¶€ ë…¸ë“œ ì‘ì€ í¬ê¸° ìœ ì§€) |
| ìºì‹œ íš¨ìœ¨ì„±   | ë‚®ìŒ     | **ë†’ìŒ**                            |

### ğŸ§­ ì™œ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ B+ Treeë¥¼ ì“¸ê¹Œ?

| ì´ìœ                            | ì„¤ëª…                                                    |
| ------------------------------ | ------------------------------------------------------- |
| ë²”ìœ„ ì¿¼ë¦¬ì— ìµœì í™”             | `BETWEEN`, `LIKE`, `>`, `<` ì²˜ë¦¬ ì„±ëŠ¥ ìš°ìˆ˜              |
| ë””ìŠ¤í¬ ë¸”ë¡ ë‹¨ìœ„ ì •ë ¬ ìœ ì§€     | ë¦¬í”„ ë…¸ë“œê°€ ì—°ê²°ëœ ë•ë¶„ì— **ì •ë ¬ëœ ìˆœì„œ ìœ ì§€**          |
| ë†’ì€ ê°€ì§€ ìˆ˜(branching factor) | íŠ¸ë¦¬ì˜ **ë†’ì´ë¥¼ ì¤„ì—¬ ë””ìŠ¤í¬ I/O ê°ì†Œ**                  |
| ë‚´ë¶€ ë…¸ë“œ ìºì‹± ìš©ì´            | ê°’ ì—†ì´ í‚¤ë§Œ ì¡´ì¬ â†’ **ë©”ëª¨ë¦¬ì— ë” ë§ì€ ë…¸ë“œ ìœ ì§€ ê°€ëŠ¥** |
| InnoDB í´ëŸ¬ìŠ¤í„° ì¸ë±ìŠ¤ êµ¬ì¡°    | MySQLì—ì„œ PK ì¸ë±ìŠ¤ë¥¼ B+ Treeë¡œ êµ¬í˜„í•¨                  |

### ğŸ“‚ InnoDB (MySQL)ì˜ B+ Tree ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ

- **PK (ê¸°ë³¸í‚¤)**: í´ëŸ¬ìŠ¤í„° ì¸ë±ìŠ¤, ì‹¤ì œ ë°ì´í„° í¬í•¨í•œ ë¦¬í”„ ë…¸ë“œ
- **ë³´ì¡° ì¸ë±ìŠ¤(Secondary Index)**: ë¦¬í”„ ë…¸ë“œì—ëŠ” PK ì£¼ì†Œë§Œ ì €ì¥
- ëª¨ë“  ì¸ë±ìŠ¤ëŠ” B+ Treeë¡œ êµ¬ì„±ë¨

### ğŸ’¬ ì¸í„°ë·°ì—ì„œ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ì§ˆë¬¸

- B-Treeì™€ B+ Treeì˜ ì°¨ì´ì ì€?
- ì™œ ë°ì´í„°ë² ì´ìŠ¤ëŠ” B+ Treeë¥¼ ì‚¬ìš©í•˜ë‚˜ìš”?
- B+ Treeì—ì„œ ì‚½ì… ì‹œ ë°œìƒí•˜ëŠ” êµ¬ì¡°ì  ë³€í™”ëŠ”?
- ë²”ìœ„ ê²€ìƒ‰ ì‹œ B+ Treeê°€ íš¨ìœ¨ì ì¸ ì´ìœ ëŠ”?

### ğŸ“Œ ì •ë¦¬ ìš”ì•½

| í•­ëª©        | B-Tree                   | B+ Tree                                       |
| ----------- | ------------------------ | --------------------------------------------- |
| ë°ì´í„° ìœ„ì¹˜ | ë‚´ë¶€/ë¦¬í”„ ëª¨ë‘           | ë¦¬í”„ì—ë§Œ ì¡´ì¬                                 |
| ë²”ìœ„ ì¿¼ë¦¬   | ëŠë¦¼                     | ë¹ ë¦„ (ë¦¬í”„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ êµ¬ì¡°)                  |
| ë””ìŠ¤í¬ I/O  | ë” ë§ìŒ                  | **ìµœì í™”ë¨** (ë†’ì´ ë‚®ê³  ì •ë ¬ ìœ ì§€)            |
| ê²€ìƒ‰ ì†ë„   | logâ‚˜N                    | logâ‚˜N                                         |
| ì‚¬ìš© ë¶„ì•¼   | ê³¼ê±° DB, ì¼ë¶€ íŒŒì¼ì‹œìŠ¤í…œ | **í˜„ëŒ€ RDBMS, InnoDB, Oracle, PostgreSQL ë“±** |

# 3.2 ê³ ê¸‰ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜

## ìµœì†Œ ë¹„ìš© ìœ ëŸ‰(Min-Cost Max Flow)

### ğŸ“Œ 1. ë¬¸ì œ ì •ì˜

**ì£¼ì–´ì§„ ìœ ëŸ‰ ê·¸ë˜í”„**ì—ì„œ

- ê° ê°„ì„ ì—ëŠ” **ìš©ëŸ‰(capacity)**ê³¼ **ë¹„ìš©(cost)**ì´ ì¡´ì¬í•˜ê³ 
- ì‹œì‘ì ì—ì„œ ì¢…ë£Œì ìœ¼ë¡œ ë³´ë‚¼ ìˆ˜ ìˆëŠ” **ìµœëŒ€ ìœ ëŸ‰(flow)**ì„ êµ¬í•˜ë˜,
- **ì´ ë¹„ìš©ì˜ í•©ì´ ìµœì†Œ**ê°€ ë˜ë„ë¡ í•œë‹¤.

### ğŸ”¢ 2. ëª¨ë¸ë§ ìš”ì†Œ

| í•­ëª©             | ì˜ë¯¸                               |
| ---------------- | ---------------------------------- |
| ì •ì  `V`         | ë…¸ë“œë“¤ (ê³µì¥, ì°½ê³ , ì†Œë¹„ì§€ ë“±)     |
| ê°„ì„  `E`         | íë¥¼ ìˆ˜ ìˆëŠ” ê²½ë¡œ                  |
| `capacity(u, v)` | ê°„ì„ (uâ†’v)ì˜ ìµœëŒ€ ìœ ëŸ‰              |
| `cost(u, v)`     | 1ë‹¨ìœ„ ìœ ëŸ‰ì´ uâ†’vë¡œ ê°ˆ ë•Œ ë“œëŠ” ë¹„ìš© |
| `flow(u, v)`     | ì‹¤ì œ íë¥´ëŠ” ìœ ëŸ‰                   |

> ëª©í‘œ:
>
> - `âˆ‘ flow = ìµœëŒ€`
> - `âˆ‘ cost Ã— flow = ìµœì†Œ`

### ğŸ” 3. í•´ê²° ì „ëµ

#### í•µì‹¬ ì•„ì´ë””ì–´:

**ìµœì†Œ ë¹„ìš©ì˜ ê²½ë¡œë¡œ ìœ ëŸ‰ì„ ë³´ë‚´ê³ **,
 ë” ì´ìƒ ë³´ë‚¼ ìˆ˜ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤.

#### ì•Œê³ ë¦¬ì¦˜ êµ¬ì„±:

1. ìœ ëŸ‰ì´ ë‚¨ì•„ ìˆëŠ” ê·¸ë˜í”„ì—ì„œ **ìµœì†Œ ë¹„ìš© ê²½ë¡œ**ë¥¼ ì°¾ëŠ”ë‹¤.
2. **ê·¸ ê²½ë¡œë¡œ ê°€ëŠ¥í•œ ë§Œí¼ ìœ ëŸ‰ì„ ë³´ë‚¸ë‹¤.**
3. ì”ì—¬ ìš©ëŸ‰ì„ ì—…ë°ì´íŠ¸í•˜ê³  1ë²ˆ ë°˜ë³µ.

### ğŸ§  í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ êµ¬ì„± ìš”ì†Œ

| ê°œë…                            | ì„¤ëª…                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| **ì”ì—¬ ê·¸ë˜í”„(Residual Graph)** | ê°„ì„ ì˜ ë‚¨ì€ ìš©ëŸ‰ê³¼ ì—­ë°©í–¥ íë¦„ì„ í‘œí˜„í•˜ëŠ” ê·¸ë˜í”„             |
| **ì—­ë°©í–¥ ê°„ì„ (back edge)**      | ìœ ëŸ‰ì„ ë˜ëŒë¦¬ëŠ” ê°„ì„ , ë¹„ìš©ì€ ìŒìˆ˜                            |
| **ìµœë‹¨ ê²½ë¡œ íƒìƒ‰**              | Dijkstra (ìŒìˆ˜ ë¹„ìš© ì—†ì„ ê²½ìš°), Bellman-Ford (ìŒìˆ˜ ë¹„ìš© í—ˆìš©) |
| **SPFA**                        | Bellman-Fordì˜ í ê¸°ë°˜ ìµœì í™” ë²„ì „                           |

### ğŸ“Š ì‹œê°„ ë³µì¡ë„ (Dijkstra + Potential ì‚¬ìš© ì‹œ)

- Dijkstra Ã— O(F Ã— E log V)
   (F: ìµœëŒ€ ìœ ëŸ‰, E: ê°„ì„  ìˆ˜, V: ì •ì  ìˆ˜)

### ğŸ§® ì˜ˆì œ ì‹œë‚˜ë¦¬ì˜¤

#### ğŸ¯ ëª©í‘œ:

ê³µì¥ì—ì„œ ê³ ê°ì—ê²Œ ë¬¼ê±´ì„ ìš´ë°˜í•  ë•Œ

- ìš´ë°˜ ê²½ë¡œë§ˆë‹¤ ìš´ì†¡ ë¹„ìš© ì¡´ì¬
- ì œí•œëœ ë¬¼ëŸ‰ë§Œ ìš´ì†¡ ê°€ëŠ¥
   â†’ ê°€ì¥ ì‹¸ê²Œ ìµœëŒ€í•œ ë§ì´ ë³´ë‚´ê¸°

```
source --(capacity=5, cost=2)--> A --(5, 1)--> sink
        \                        /
         --(3, 4)--> B --(3, 1)--
```

> ëª©í‘œ: source â†’ sinkë¡œ ìµœëŒ€ ìœ ëŸ‰ì„ ë³´ë‚´ë˜, ì´ ë¹„ìš© ìµœì†Œ

### ğŸ§© ì•Œê³ ë¦¬ì¦˜ ì˜ˆì‹œ (SPFA ë²„ì „ì˜ Min-Cost Max Flow)

```
struct Edge {
    int to, rev;
    int cap, cost;
};

vector<Edge> graph[MAX];
int dist[MAX], prevv[MAX], preve[MAX];

void addEdge(int from, int to, int cap, int cost) {
    graph[from].push_back({to, (int)graph[to].size(), cap, cost});
    graph[to].push_back({from, (int)graph[from].size() - 1, 0, -cost});
}

int minCostMaxFlow(int s, int t, int& totalCost) {
    int flow = 0;
    totalCost = 0;
    const int INF = 1e9;

    while (true) {
        fill(dist, dist + MAX, INF);
        dist[s] = 0;
        bool inQueue[MAX] = {};
        queue<int> q;
        q.push(s);

        while (!q.empty()) {
            int v = q.front(); q.pop();
            inQueue[v] = false;
            for (int i = 0; i < graph[v].size(); ++i) {
                Edge& e = graph[v][i];
                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {
                    dist[e.to] = dist[v] + e.cost;
                    prevv[e.to] = v;
                    preve[e.to] = i;
                    if (!inQueue[e.to]) {
                        q.push(e.to);
                        inQueue[e.to] = true;
                    }
                }
            }
        }

        if (dist[t] == INF) break;

        // ê°€ëŠ¥í•œ ìœ ëŸ‰ë§Œí¼ ë³´ë‚´ê¸°
        int d = INF;
        for (int v = t; v != s; v = prevv[v])
            d = min(d, graph[prevv[v]][preve[v]].cap);
        flow += d;
        totalCost += d * dist[t];
        for (int v = t; v != s; v = prevv[v]) {
            Edge& e = graph[prevv[v]][preve[v]];
            e.cap -= d;
            graph[v][e.rev].cap += d;
        }
    }
    return flow;
}
```

### âœ… ì‹¤ì „ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

| ë°©ë²•                             | íŠ¹ì§•                                        |
| -------------------------------- | ------------------------------------------- |
| Bellman-Ford                     | ìŒìˆ˜ ë¹„ìš© ê°€ëŠ¥, ëŠë¦¼                        |
| SPFA                             | Bellman-Ford ìµœì í™”, ë³´í†µ ë¹ ë¦„              |
| Dijkstra + Potential (Johnsonâ€™s) | ë¹„ìš©ì´ ìŒìˆ˜ ì—†ê±°ë‚˜ ì¡°ì • ê°€ëŠ¥í•  ë•Œ ë§¤ìš° ë¹ ë¦„ |

### ğŸ’¡ ì‹¤ì „ ì‘ìš© ì‚¬ë¡€

| ë¶„ì•¼          | ì˜ˆì‹œ                                  |
| ------------- | ------------------------------------- |
| ë¬¼ë¥˜ ìµœì í™”   | ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ íŠ¸ëŸ­ ë¬¼ëŸ‰ ë¶„ë°°          |
| ì‘ì—… ìŠ¤ì¼€ì¤„ë§ | ìµœì†Œ ì¸ê±´ë¹„ë¡œ ì‘ì—… í• ë‹¹               |
| ê³µì • ì œì–´     | ìµœëŒ€ ì²˜ë¦¬ëŸ‰ í™•ë³´í•˜ë©° ì „ë ¥ ë¹„ìš© ìµœì†Œí™” |
| ì „ë ¥ë§ ë¶„ë°°   | ìµœëŒ€ ì „ì†¡ëŸ‰ + ìµœì†Œ ì†¡ì „ ë¹„ìš©          |
| ë„¤íŠ¸ì›Œí¬ QoS  | ëŒ€ì—­í­ ìµœëŒ€ í™•ë³´ + ë¹„ìš© ìµœì†Œ          |
| ëŒ€í•™ ë°°ì •     | ì •ì› ê³ ë ¤ + ë§Œì¡±ë„ ê¸°ë°˜ ë°°ì •          |

### ğŸ’¬ ì¸í„°ë·°/ë¬¸ì œ í’€ì´ì—ì„œ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ì§ˆë¬¸

- ìœ ëŸ‰ ë¬¸ì œì—ì„œ ë¹„ìš©ê¹Œì§€ ê³ ë ¤í•˜ëŠ” ì´ìœ ëŠ”?
- SPFA ë°©ì‹ê³¼ Dijkstra ë°©ì‹ì˜ ì°¨ì´ëŠ”?
- ì”ì—¬ ê·¸ë˜í”„ë€?
- ì™œ ì—­ë°©í–¥ ê°„ì„ ì— ìŒìˆ˜ ë¹„ìš©ì„ ë‘ëŠ”ê°€?
- Min-Cost FlowëŠ” ì–¸ì œ ì¢…ë£Œë˜ëŠ”ê°€?

### ğŸ“Œ ìš”ì•½

| í•­ëª©                  | ë‚´ìš©                                    |
| --------------------- | --------------------------------------- |
| ëª©í‘œ                  | ìµœëŒ€ ìœ ëŸ‰, ìµœì†Œ ë¹„ìš©                    |
| í•µì‹¬ ì•Œê³ ë¦¬ì¦˜         | ìµœë‹¨ ê²½ë¡œ ê¸°ë°˜ ìœ ëŸ‰ ì¦ëŒ€ ë°˜ë³µ           |
| ì”ì—¬ ìš©ëŸ‰/ì—­ë°©í–¥ ê°„ì„  | í•„ìˆ˜                                    |
| ì„±ëŠ¥                  | O(F Ã— E log V) ì •ë„                     |
| ì‹¤ì œ í™œìš©ë„           | ë§¤ìš° ë†’ìŒ (ë¬¼ë¥˜, ë„¤íŠ¸ì›Œí¬, ìŠ¤ì¼€ì¤„ë§ ë“±) |

## ìµœëŒ€ ìœ ëŸ‰ (Ford-Fulkerson, Edmonds-Karp)

### ğŸ“Œ ë¬¸ì œ ì •ì˜

**ìœ ëŸ‰ ë„¤íŠ¸ì›Œí¬**ì—ì„œ **ì‹œì‘ì (source)**ì—ì„œ **ì¢…ë£Œì (sink)**ê¹Œì§€
 íë¥¼ ìˆ˜ ìˆëŠ” **ìµœëŒ€ ìœ ëŸ‰ì˜ ì–‘**ì„ êµ¬í•˜ëŠ” ê²ƒì´ ëª©ì .

> âš ï¸ ê° ê°„ì„ ì—ëŠ” **ìš©ëŸ‰(capacity)**ì´ ìˆê³ , ì´ë¥¼ ë„˜ì„ ìˆ˜ëŠ” ì—†ì–´

### ğŸ“¦ ê·¸ë˜í”„ êµ¬ì„± ìš”ì†Œ

| í•­ëª©            | ì„¤ëª…                     |
| --------------- | ------------------------ |
| ì •ì (V)         | ë…¸ë“œë“¤ (ê³µì¥, ì†¡ì‹ ê¸° ë“±) |
| ê°„ì„ (E)         | íë¦„ì´ ê°€ëŠ¥í•œ ê²½ë¡œ       |
| `capacity(u,v)` | ê°„ì„ (uâ†’v)ì˜ ìµœëŒ€ ìœ ëŸ‰    |
| `flow(u,v)`     | ì‹¤ì œ íë¥´ëŠ” ìœ ëŸ‰         |

> ëª©ì :
>
> - `flow`ëŠ” `capacity`ë¥¼ ë„˜ì§€ ì•Šì•„ì•¼ í•˜ë©°
> - ê° ì •ì ì—ì„œëŠ” ìœ ì… = ìœ ì¶œ (`source`, `sink` ì œì™¸)

### ğŸ” ê¸°ë³¸ ì „ëµ: Ford-Fulkerson ë°©ë²•

1. ìœ ëŸ‰ì„ 0ìœ¼ë¡œ ì´ˆê¸°í™”
2. **ì”ì—¬ ìš©ëŸ‰(residual capacity)ì´ ìˆëŠ” ê²½ë¡œ**ë¥¼ ì°¾ì•„ ìœ ëŸ‰ì„ ë”í•¨
3. **ë°˜ë³µ** â†’ ë” ì´ìƒ augmenting pathê°€ ì—†ì„ ë•Œ ì¢…ë£Œ

### ğŸ” ì”ì—¬ ê·¸ë˜í”„(Residual Graph)

- ê°„ì„ ì˜ **ë‚¨ì€ ìš©ëŸ‰**ì„ ë‚˜íƒ€ë‚´ëŠ” ê·¸ë˜í”„
- ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ **ì—­ë°©í–¥ ê°„ì„ ë„ ì¡´ì¬** (flow ë˜ëŒë¦¬ê¸° ê°€ëŠ¥)

```
edge(u â†’ v), capacity=5, flow=3 â†’ residual=2
â†’ ì—­ë°©í–¥ edge(v â†’ u) with capacity=3
```

### ğŸ§  Edmonds-Karp ì•Œê³ ë¦¬ì¦˜

Ford-Fulkersonì˜ íŠ¹ìˆ˜í•œ êµ¬í˜„:
 ë§¤ë²ˆ **BFSë¡œ ê°€ì¥ ì§§ì€ ê²½ë¡œ**ë¥¼ ì„ íƒ

- **ì‹œê°„ ë³µì¡ë„**: O(V Ã— EÂ²)
- ìœ ëŸ‰ì´ ì¦ê°€í•˜ëŠ” ê³¼ì •ì´ ì•ˆì •ì ì´ë©°, ë¬´í•œ ë£¨í”„ ë°©ì§€

### ğŸ”§ C++ ì˜ˆì œ ì½”ë“œ (Edmonds-Karp)

```
const int INF = 1e9;
int capacity[MAX][MAX], flow[MAX][MAX];
vector<int> graph[MAX];

int bfs(int s, int t, vector<int>& parent) {
    fill(parent.begin(), parent.end(), -1);
    parent[s] = s;
    queue<pair<int, int>> q;
    q.push({s, INF});

    while (!q.empty()) {
        int cur = q.front().first;
        int f = q.front().second;
        q.pop();

        for (int next : graph[cur]) {
            if (parent[next] == -1 && capacity[cur][next] - flow[cur][next] > 0) {
                parent[next] = cur;
                int new_flow = min(f, capacity[cur][next] - flow[cur][next]);
                if (next == t) return new_flow;
                q.push({next, new_flow});
            }
        }
    }
    return 0;
}

int maxFlow(int s, int t) {
    int total_flow = 0;
    vector<int> parent(MAX);
    int new_flow;

    while ((new_flow = bfs(s, t, parent))) {
        total_flow += new_flow;
        int cur = t;
        while (cur != s) {
            int prev = parent[cur];
            flow[prev][cur] += new_flow;
            flow[cur][prev] -= new_flow;
            cur = prev;
        }
    }
    return total_flow;
}
```

### ğŸ“Š ì‹œê°„ ë³µì¡ë„ ë¹„êµ

| ì•Œê³ ë¦¬ì¦˜             | ì‹œê°„ë³µì¡ë„                   |
| -------------------- | ---------------------------- |
| Ford-Fulkerson (DFS) | O(E Ã— maxFlow)               |
| Edmonds-Karp (BFS)   | O(V Ã— EÂ²)                    |
| Dinic                | O(E Ã— VÂ²), ì¼ë¶€ ê²½ìš° O(âˆšV E) |

### ğŸ’¡ ì˜ˆì œ ë¬¸ì œ

> âš™ï¸ â€œë„¤íŠ¸ì›Œí¬ê°€ ì£¼ì–´ì§ˆ ë•Œ, source â†’ sinkë¡œ ë³´ë‚¼ ìˆ˜ ìˆëŠ” ìµœëŒ€ ìœ ëŸ‰ì„ êµ¬í•˜ë¼â€

#### ì˜ˆì‹œ ì…ë ¥:

```
4 nodes, source=0, sink=3

Edges:
0 â†’ 1 (capacity: 10)
0 â†’ 2 (capacity: 5)
1 â†’ 2 (capacity: 15)
1 â†’ 3 (capacity: 10)
2 â†’ 3 (capacity: 10)
```

#### ì •ë‹µ:

- ê°€ëŠ¥í•œ ìœ ëŸ‰:
  - 0 â†’ 1 â†’ 3: 10
  - 0 â†’ 2 â†’ 3: 5
     â†’ ìµœëŒ€ ìœ ëŸ‰: **15**

### ğŸ“š í™œìš© ì‚¬ë¡€

| ë¶„ì•¼          | ì„¤ëª…                                   |
| ------------- | -------------------------------------- |
| ë„¤íŠ¸ì›Œí¬ ì„¤ê³„ | ë°ì´í„°/ì „ë ¥ ìµœì  ë¶„ë°°                  |
| ë¬¼ë¥˜ ìµœì í™”   | ê²½ë¡œë³„ ì œí•œ ê³ ë ¤í•œ ë¬¼ëŸ‰ ë¶„ë°°           |
| ì´ë¯¸ì§€ ì„¸ë¶„í™” | ê·¸ë˜í”„ ì»· ê¸°ë°˜ ë¶„ë¦¬                    |
| ì´ë¶„ ë§¤ì¹­     | ì‚¬ëŒê³¼ ì‘ì—… ë§¤ì¹­, í—ê°€ë¦¬ ì•Œê³ ë¦¬ì¦˜ ì—°ê³„ |
| ëŒ€íšŒ ì•Œê³ ë¦¬ì¦˜ | MCMF, Matching, Dinic ê¸°ë°˜ ë¬¸ì œë“¤      |

### ğŸ’¬ ìì£¼ ë‚˜ì˜¤ëŠ” ì§ˆë¬¸

- Ford-Fulkersonê³¼ Edmonds-Karpì˜ ì°¨ì´ëŠ”?
- ì—­ë°©í–¥ ê°„ì„ ì´ ì™œ í•„ìš”í•œê°€?
- ìœ ëŸ‰ ë³´ì¡´ ì¡°ê±´ì´ë€?
- ì”ì—¬ ìš©ëŸ‰ ê·¸ë˜í”„ë€ ë¬´ì—‡ì¸ê°€?
- ì´ë¶„ ë§¤ì¹­ ë¬¸ì œë¥¼ ìµœëŒ€ ìœ ëŸ‰ìœ¼ë¡œ ë°”ê¾¸ëŠ” ë°©ë²•ì€?

### âœ… ìš”ì•½

| í•­ëª©        | ì„¤ëª…                                        |
| ----------- | ------------------------------------------- |
| ì…ë ¥        | ì •ì  ìˆ˜, ê°„ì„ , ìš©ëŸ‰                         |
| ì¶œë ¥        | ì‹œì‘ì ì—ì„œ ëì ìœ¼ë¡œ ë³´ë‚¼ ìˆ˜ ìˆëŠ” ìµœëŒ€ ìœ ëŸ‰  |
| í•µì‹¬ êµ¬ì„±   | ì”ì—¬ ìš©ëŸ‰, augmenting path, ì—­ë°©í–¥ ê°„ì„      |
| êµ¬í˜„ ë°©ì‹   | DFS, BFS, Dinic                             |
| ìµœì í™” ê¸°ë²• | BFS + ë ˆë²¨ ê·¸ë˜í”„ (Dinic), ìš©ëŸ‰ ìŠ¤ì¼€ì¼ë§ ë“± |

## Strongly Connected Components (Tarjan, Kosaraju)

### ğŸ“Œ 1. ê°œë… ì •ì˜

**ê°•í•œ ì—°ê²° ìš”ì†Œ(SCC, Strongly Connected Component)**ë€
 **ìœ í–¥ ê·¸ë˜í”„**ì—ì„œ **ì–´ë–¤ ë‘ ì •ì  u, vê°€ ì„œë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ** ìµœëŒ€ ì •ì  ì§‘í•©ì„ ë§í•œë‹¤.

ì¦‰,

- `u â†’ v`
- `v â†’ u`
   â†’ **ì–‘ë°©í–¥ ë„ë‹¬ ê°€ëŠ¥**í•œ ì •ì ë¼ë¦¬ ë¬¶ì¸ ì§‘í•©ì´ SCC

### ğŸ“ 2. ì˜ˆì‹œ

```
A â†’ B â†’ C â†’ A     â†’ SCC #1: {A, B, C}
D â†’ E             â†’ SCC #2: {D}, SCC #3: {E}
```

ê° SCCëŠ” **ì„œë¡œ ë‹¤ë¥¸ DAG(ë¹„ìˆœí™˜ ê·¸ë˜í”„)**ì˜ ë…¸ë“œì²˜ëŸ¼ ì—°ê²°ëœë‹¤.

### ğŸ“Š 3. SCCì˜ ì„±ì§ˆ

| íŠ¹ì„±                     | ì„¤ëª…                                         |
| ------------------------ | -------------------------------------------- |
| ìœ í–¥ ê·¸ë˜í”„ì—ì„œë§Œ ì •ì˜ë¨ | ë¬´ë°©í–¥ ê·¸ë˜í”„ëŠ” ëª¨ë“  ì—°ê²° ìš”ì†Œê°€ SCC         |
| ê·¸ë˜í”„ ì••ì¶• ê°€ëŠ¥         | SCCë“¤ì„ í•˜ë‚˜ì˜ ë…¸ë“œë¡œ ì·¨ê¸‰í•˜ë©´ DAG êµ¬ì¡°ê°€ ë¨ |
| ìœ„ìƒ ì •ë ¬ ê°€ëŠ¥           | SCC ì••ì¶• ê·¸ë˜í”„ëŠ” í•­ìƒ DAGì´ë¯€ë¡œ ê°€ëŠ¥        |

### ğŸ” 4. SCC íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ 2ê°€ì§€

| ì•Œê³ ë¦¬ì¦˜     | íŠ¹ì§•                                                   |
| ------------ | ------------------------------------------------------ |
| **Tarjan**   | DFS ê¸°ë°˜, **ìŠ¤íƒ + ì‹œê°„ ê´€ë¦¬**, í•œ ë²ˆì˜ DFSë¡œ SCC ì¶”ì¶œ |
| **Kosaraju** | 2-pass DFS: ì—­ë°©í–¥ ê·¸ë˜í”„ + í›„ìœ„ìˆœìœ¼ë¡œ SCC íƒìƒ‰        |

### ğŸ”§ 5. Tarjanâ€™s Algorithm (ë‹¨ì¼ DFS ê¸°ë°˜)

#### ğŸ§  í•µì‹¬ ê°œë…

- ê° ì •ì ì— ëŒ€í•´ **DFS ë°©ë¬¸ ìˆœì„œ (id)** ê¸°ë¡
- **low-link**: ìì‹  ë˜ëŠ” í•˜ìœ„ ë…¸ë“œ ì¤‘ ê°€ì¥ ë¹ ë¥¸ ë°©ë¬¸ ìˆœì„œ
- DFS ê³¼ì • ì¤‘ **ìê¸° ìì‹ ìœ¼ë¡œ ëŒì•„ì˜¬ ìˆ˜ ìˆëŠ”ì§€ íŒë‹¨**
- **ìŠ¤íƒì„ ì´ìš©í•œ íƒìƒ‰ ê²½ë¡œ ê´€ë¦¬**

#### ğŸ§© í•µì‹¬ íë¦„

1. DFSë¡œ ë°©ë¬¸í•˜ë©° `id`, `low-link` ê°±ì‹ 
2. ìŠ¤íƒì— push
3. `id == low-link`ì¼ ë•Œ â†’ SCC ì¶”ì¶œ (ìŠ¤íƒì—ì„œ pop)

#### âœ… C++ ì½”ë“œ ì˜ˆì‹œ (Tarjan)

```
vector<int> graph[MAX];
bool onStack[MAX];
int id[MAX], low[MAX], sccId[MAX], nodeId = 0, sccCount = 0;
stack<int> st;

void dfs(int u) {
    id[u] = low[u] = nodeId++;
    st.push(u); onStack[u] = true;

    for (int v : graph[u]) {
        if (id[v] == -1) {
            dfs(v);
            low[u] = min(low[u], low[v]);
        } else if (onStack[v]) {
            low[u] = min(low[u], id[v]);
        }
    }

    if (id[u] == low[u]) {
        while (true) {
            int v = st.top(); st.pop();
            onStack[v] = false;
            sccId[v] = sccCount;
            if (v == u) break;
        }
        sccCount++;
    }
}
```

- ì „ì²´ DFS ì‹¤í–‰:

```
memset(id, -1, sizeof(id));
for (int i = 0; i < n; ++i)
    if (id[i] == -1) dfs(i);
```

### ğŸ”„ 6. Kosarajuâ€™s Algorithm (2-pass DFS)

#### ğŸ§  í•µì‹¬ íë¦„

1. **ì›ë˜ ê·¸ë˜í”„ì—ì„œ DFS ìˆ˜í–‰ â†’ ì •ì  í›„ìœ„ ìˆœì„œ ê¸°ë¡**
2. **ê·¸ë˜í”„ì˜ ëª¨ë“  ê°„ì„ ì„ ë’¤ì§‘ìŒ (transpose graph)**
3. í›„ìœ„ ìˆœì„œëŒ€ë¡œ **ì—­ë°©í–¥ ê·¸ë˜í”„ì— ëŒ€í•´ DFS** ìˆ˜í–‰
4. ê° DFS í˜¸ì¶œì´ í•˜ë‚˜ì˜ SCCê°€ ë¨

#### âœ… ì¥ì 

- ì§ê´€ì ì´ê³  êµ¬í˜„ ê°„ë‹¨
- ë‘ ë²ˆì˜ DFSë¡œ SCC ë„ì¶œ ê°€ëŠ¥

#### âœ… Kosaraju ì½”ë“œ íë¦„

```
vector<int> graph[MAX], revGraph[MAX], order;
bool visited[MAX];
vector<vector<int>> sccs;

void dfs1(int u) {
    visited[u] = true;
    for (int v : graph[u])
        if (!visited[v]) dfs1(v);
    order.push_back(u);
}

void dfs2(int u, vector<int>& scc) {
    visited[u] = true;
    scc.push_back(u);
    for (int v : revGraph[u])
        if (!visited[v]) dfs2(v, scc);
}

void kosaraju(int n) {
    fill(visited, visited + n, false);
    for (int i = 0; i < n; i++)
        if (!visited[i]) dfs1(i);

    fill(visited, visited + n, false);
    reverse(order.begin(), order.end());

    for (int u : order) {
        if (!visited[u]) {
            vector<int> scc;
            dfs2(u, scc);
            sccs.push_back(scc);
        }
    }
}
```

### ğŸ“¦ 7. ì‚¬ìš© ì‚¬ë¡€

| ë¶„ì•¼                   | ì„¤ëª…                  |
| ---------------------- | --------------------- |
| ìˆœí™˜ ì˜ì¡´ì„± ë¶„ì„       | ì»´íŒŒì¼ëŸ¬ ëª¨ë“ˆ, íŒ¨í‚¤ì§€ |
| íšŒë¡œ ìµœì í™”            | ìˆœí™˜ ë£¨í”„ ì œê±°        |
| ìƒíƒœê¸°ê³„ ë¶„ì„          | ìƒíƒœ ìˆœí™˜ íƒì§€        |
| ì›¹ í¬ë¡¤ëŸ¬, ê·¸ë˜í”„ ì••ì¶• | ì—°ê²°ëœ ì‚¬ì´íŠ¸ ê·¸ë£¹í™”  |
| ì†Œì…œ ë„¤íŠ¸ì›Œí¬ ë¶„ì„     | ê°•í•œ ì˜í–¥ ê·¸ë£¹ íƒìƒ‰   |

### ğŸ’¬ ìì£¼ ë‚˜ì˜¤ëŠ” ì§ˆë¬¸

- DFSë¡œ SCCë¥¼ ì°¾ì„ ìˆ˜ ìˆëŠ” ì´ìœ ëŠ”?
- low-linkê°€ ì˜ë¯¸í•˜ëŠ” ê²ƒì€?
- Tarjanê³¼ Kosarajuì˜ ì°¨ì´ì ì€?
- SCCë¥¼ DAGë¡œ ì••ì¶•í•˜ë©´ ì–´ë–¤ ì´ì ì´ ìˆë‚˜?
- SCCë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìœ„ìƒ ì •ë ¬í•˜ë ¤ë©´?

### ğŸ“Œ ìš”ì•½ ì •ë¦¬

| í•­ëª©       | ë‚´ìš©                                               |
| ---------- | -------------------------------------------------- |
| ì •ì˜       | ëª¨ë“  ì •ì ì´ ì„œë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ ì„œë¸Œê·¸ë˜í”„            |
| ì¡°ê±´       | uâ†’v, vâ†’u ëª¨ë‘ ê°€ëŠ¥í•´ì•¼ í•¨                          |
| ì•Œê³ ë¦¬ì¦˜   | Tarjan(DFS), Kosaraju(2-pass)                      |
| ì‹œê°„ë³µì¡ë„ | O(V + E) (ë‘˜ ë‹¤ ë™ì¼)                              |
| í™œìš©       | ìˆœí™˜ íƒì§€, ìœ„ìƒ ì •ë ¬, ì»´íŒŒì¼ëŸ¬ ìµœì í™”, ê·¸ë˜í”„ ì••ì¶• |

## Heavy-Light Decomposition (HLD)

### ğŸ“Œ 1. ê°œìš”

**HLD**ëŠ” íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ **heavy edgeì™€ light edgeë¡œ ë‚˜ëˆ ì„œ**,
 íŠ¸ë¦¬ì˜ ê²½ë¡œë¥¼ **ì‘ì€ ê°œìˆ˜ì˜ ì„¸ê·¸ë¨¼íŠ¸ë¡œ ë¶„í•´**í•´ì£¼ëŠ” ìë£Œêµ¬ì¡° ê¸°ë²•ì´ë‹¤.

> ëª©ì :
>  **íŠ¸ë¦¬ì˜ ë‘ ë…¸ë“œ ì‚¬ì´ ê²½ë¡œì— ëŒ€í•œ ì¿¼ë¦¬/ì—…ë°ì´íŠ¸**ë¥¼ `O(log n)`ì— ì²˜ë¦¬ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.

### ğŸ” 2. í•´ê²°í•˜ë ¤ëŠ” ë¬¸ì œ ì˜ˆì‹œ

- **u ~ v ê²½ë¡œì˜ ìµœëŒ“ê°’/í•©**
- **íŠ¸ë¦¬ ê²½ë¡œì˜ XOR ê³„ì‚°**
- **ì„œë¸ŒíŠ¸ë¦¬ ì¿¼ë¦¬**
- **ê²½ë¡œìƒì˜ ë…¸ë“œ ê°œìˆ˜, ì¡°ê±´ ë§Œì¡± ë…¸ë“œ ìˆ˜ ë“±**

ë³´í†µ ë‹¨ìˆœ íŠ¸ë¦¬ íƒìƒ‰ìœ¼ë¡œëŠ” ì²˜ë¦¬ ë¶ˆê°€ëŠ¥í•˜ê±°ë‚˜ ëŠë¦° ë¬¸ì œë¥¼
 â†’ HLD + ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ì¡°í•©ìœ¼ë¡œ í•´ê²°

### ğŸ§  3. í•µì‹¬ ì•„ì´ë””ì–´ ìš”ì•½

1. íŠ¸ë¦¬ì˜ ê°„ì„ /ìì‹ ì¤‘ **ê°€ì¥ í° ì„œë¸ŒíŠ¸ë¦¬ë¡œ í–¥í•˜ëŠ” ê°„ì„ **ì„ `heavy edge`ë¡œ ì§€ì •
2. ë‚˜ë¨¸ì§€ ê°„ì„ ì€ `light edge`ë¡œ ë‘”ë‹¤
3. íŠ¸ë¦¬ë¥¼ **heavy pathë“¤ë¡œ ë¶„í•´**í•´ì„œ **ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ì¸ë±ìŠ¤**ë¥¼ ì§€ì •í•œë‹¤
4. ì¿¼ë¦¬ë¥¼ **ê²½ë¡œ êµ¬ê°„ ì¿¼ë¦¬ë¡œ í™˜ì›**ì‹œì¼œ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¡œ ì²˜ë¦¬

### ğŸ“ 4. ìš©ì–´ ì •ë¦¬

| ìš©ì–´              | ì„¤ëª…                                      |
| ----------------- | ----------------------------------------- |
| **heavy edge**    | ìì‹ ì¤‘ ì„œë¸ŒíŠ¸ë¦¬ í¬ê¸°ê°€ ê°€ì¥ í° ê°„ì„       |
| **light edge**    | ë‚˜ë¨¸ì§€ ìì‹ìœ¼ë¡œ í–¥í•˜ëŠ” ê°„ì„                |
| **chain**         | ì—°ì†ëœ heavy edgeë“¤ë¡œ êµ¬ì„±ëœ ê²½ë¡œ         |
| **head**          | ê° ì²´ì¸ì˜ ì‹œì‘ì  ë…¸ë“œ                     |
| **in[node]**      | ë…¸ë“œê°€ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ìƒì— ë§¤í•‘ë˜ëŠ” ì¸ë±ìŠ¤ |
| **parent[node]**  | ë¶€ëª¨ ë…¸ë“œ                                 |
| **depth[node]**   | ë£¨íŠ¸ë¡œë¶€í„°ì˜ ê¹Šì´                         |
| **subsize[node]** | ì„œë¸ŒíŠ¸ë¦¬ í¬ê¸°                             |

### ğŸ”§ 5. HLD êµ¬í˜„ ì ˆì°¨ ìš”ì•½

1ï¸âƒ£ **DFS1: ì„œë¸ŒíŠ¸ë¦¬ í¬ê¸° ê³„ì‚° + heavy child ì§€ì •**

```
void dfs1(int u, int p) {
    parent[u] = p;
    subsize[u] = 1;
    int maxSub = -1;

    for (int v : tree[u]) {
        if (v == p) continue;
        depth[v] = depth[u] + 1;
        dfs1(v, u);
        subsize[u] += subsize[v];
        if (subsize[v] > maxSub) {
            maxSub = subsize[v];
            heavy[u] = v;
        }
    }
}
```

2ï¸âƒ£ **DFS2: ì²´ì¸ ë¶„í•  + ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ì¸ë±ìŠ¤ ë¶€ì—¬**

```
void dfs2(int u, int h) {
    head[u] = h;
    in[u] = curPos++; // ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ì¸ë±ìŠ¤
    if (heavy[u] != -1) dfs2(heavy[u], h); // ê°™ì€ ì²´ì¸ ê³„ì†

    for (int v : tree[u]) {
        if (v != parent[u] && v != heavy[u])
            dfs2(v, v); // ìƒˆë¡œìš´ ì²´ì¸ ì‹œì‘
    }
}
```

### ğŸ” 6. ê²½ë¡œ ì¿¼ë¦¬ ì²˜ë¦¬ ë°©ì‹

```
int query(int u, int v) {
    int res = 0;
    while (head[u] != head[v]) {
        if (depth[head[u]] < depth[head[v]]) swap(u, v);
        res += seg.query(in[head[u]], in[u]);
        u = parent[head[u]];
    }
    if (depth[u] > depth[v]) swap(u, v);
    res += seg.query(in[u], in[v]); // ê°™ì€ ì²´ì¸
    return res;
}
```

### ğŸ§® ì‹œê°„ ë³µì¡ë„

| ì—°ì‚°               | ì‹œê°„                                            |
| ------------------ | ----------------------------------------------- |
| ì „ì²˜ë¦¬             | O(N) (ë‘ ë²ˆì˜ DFS)                              |
| ê²½ë¡œ ì¿¼ë¦¬/ì—…ë°ì´íŠ¸ | O(logÂ² N) (log N ì²´ì¸ ìˆ˜ Ã— log N ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬) |
| ì„œë¸ŒíŠ¸ë¦¬ ì¿¼ë¦¬      | O(log N)                                        |

### ğŸ¹ ê²½ë¡œ ì¿¼ë¦¬ vs ì„œë¸ŒíŠ¸ë¦¬ ì¿¼ë¦¬

| ì¿¼ë¦¬ ì¢…ë¥˜         | ëŒ€ì‘ ë°©ì‹                                    |
| ----------------- | -------------------------------------------- |
| u ~ v ê²½ë¡œ ì¿¼ë¦¬   | HLD ì²´ì¸ jump + ì„¸ê·¸ë¨¼íŠ¸ ì¿¼ë¦¬                |
| uì˜ ì„œë¸ŒíŠ¸ë¦¬ ì¿¼ë¦¬ | `in[u] ~ out[u]`ë¡œ ì²˜ë¦¬ (ë³„ë„ DFS ì‹œê°„ ê¸°ë¡) |

### ğŸ“š í™œìš© ë¬¸ì œ ìœ í˜•

| ë¬¸ì œ ìœ í˜•                     | HLD í™œìš© ì—¬ë¶€ |
| ----------------------------- | ------------- |
| íŠ¸ë¦¬ ê²½ë¡œ ì¿¼ë¦¬ (í•©, ìµœëŒ€ ë“±)  | âœ… í•„ìˆ˜        |
| LCAë¥¼ í™œìš©í•œ ê²½ë¡œ ë¶„í•  ë¬¸ì œ   | âœ… ìì£¼ ì“°ì„   |
| íŠ¸ë¦¬ ìœ„ì— Binary Indexed Tree | âœ… êµ¬ì¡° ìœ ì‚¬   |
| centroid decomposition        | âŒ ë‹¤ë¥¸ ë°©ì‹   |

### ğŸ’¬ ì¸í„°ë·°/ì‹¤ì „ ì§ˆë¬¸

- HLDì˜ ëª©ì ì€ ë¬´ì—‡ì¸ê°€ìš”?
- ì–´ë–»ê²Œ ê²½ë¡œë¥¼ ë¶„í•´í•˜ë‚˜ìš”?
- ì™œ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¥¼ ì“°ë‚˜ìš”?
- ê²½ë¡œ ì¿¼ë¦¬ë¥¼ logÂ² Nì— í•˜ëŠ” ì´ìœ ëŠ”?

### âœ… ì •ë¦¬ ìš”ì•½

| í•­ëª©          | ì„¤ëª…                                           |
| ------------- | ---------------------------------------------- |
| ëª©ì           | íŠ¸ë¦¬ ê²½ë¡œ ì¿¼ë¦¬ë¥¼ ë¹ ë¥´ê²Œ ì²˜ë¦¬                   |
| ë°©ì‹          | íŠ¸ë¦¬ë¥¼ heavy pathë¡œ ë¶„í•´ í›„ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ë§¤í•‘ |
| í•µì‹¬ ìë£Œêµ¬ì¡° | ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬, in[], head[], parent[]          |
| ì‹œê°„ë³µì¡ë„    | O(logÂ² N) ê²½ë¡œ ì¿¼ë¦¬                            |
| ì‘ìš©          | íŠ¸ë¦¬ ì¿¼ë¦¬, íŠ¸ë¦¬ ë‹¤ì´ë‚˜ë¯¹, ë„¤íŠ¸ì›Œí¬             |

# 3.3 ë¬¸ìì—´ ì•Œê³ ë¦¬ì¦˜

## KMP ì•Œê³ ë¦¬ì¦˜

### ğŸ“Œ 1. ë¬¸ì œ ì •ì˜

> **ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ Tì—ì„œ, íŒ¨í„´ Pê°€ ì²˜ìŒ ë“±ì¥í•˜ëŠ” ìœ„ì¹˜(ë“¤)ë¥¼ O(N) ì‹œê°„ì— ì°¾ì•„ë¼.**

#### âŒ ë¸Œë£¨íŠ¸í¬ìŠ¤ì˜ í•œê³„

ê¸°ì¡´ì˜ naive ë°©ì‹ì€:

- ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ íŒ¨í„´ì„ **í•œ ì¹¸ ë’¤ë¡œ ë°€ê³  ì²˜ìŒë¶€í„° ë‹¤ì‹œ ë¹„êµ**
- ìµœì•…ì˜ ê²½ìš° `O(NM)` (í…ìŠ¤íŠ¸ ê¸¸ì´ N, íŒ¨í„´ ê¸¸ì´ M)

```
T = abababababc
P = abababc
```

íŒ¨í„´ì´ ê²¹ì¹˜ëŠ” êµ¬ì¡°ì¼ìˆ˜ë¡ ë°˜ë³µ ë¹„êµê°€ ë§ì•„ì§ â†’ ë¹„íš¨ìœ¨

### âœ… KMPì˜ í•µì‹¬ ì•„ì´ë””ì–´

> "ì¼ì¹˜í•˜ë˜ ë¶€ë¶„ì€ **ë‹¤ì‹œ ë¹„êµí•˜ì§€ ì•Šì•„ë„ ëœë‹¤**!"

#### âœ¨ í•µì‹¬:

**ì ‘ë‘ì‚¬ == ì ‘ë¯¸ì‚¬**ì¸ êµ¬ì¡°ë¥¼ ì´ìš©í•´,
 **ì‹¤íŒ¨í–ˆë˜ ë¶€ë¶„ê¹Œì§€ì˜ ì •ë³´**ë¥¼ í™œìš©í•˜ì—¬ **íŒ¨í„´ì„ ì í”„**í•¨.

### ğŸ§  í•µì‹¬ êµ¬ì„±

| êµ¬ì„± ìš”ì†Œ       | ì„¤ëª…                                |
| --------------- | ----------------------------------- |
| `T` (í…ìŠ¤íŠ¸)    | ì „ì²´ ë¬¸ìì—´ (ê¸¸ì´ N)                |
| `P` (íŒ¨í„´)      | ì°¾ê³ ì í•˜ëŠ” ë¶€ë¶„ ë¬¸ìì—´ (ê¸¸ì´ M)    |
| **LPS ë°°ì—´**    | íŒ¨í„´ì˜ ì ‘ë‘ì‚¬/ì ‘ë¯¸ì‚¬ ì¼ì¹˜ ì •ë³´ ì €ì¥ |
| ë¹„êµ ì¸ë±ìŠ¤ `i` | í…ìŠ¤íŠ¸ ìœ„ì¹˜                         |
| ë¹„êµ ì¸ë±ìŠ¤ `j` | íŒ¨í„´ ìœ„ì¹˜                           |

### ğŸ“¦ LPS ë°°ì—´ (Longest Prefix Suffix)

> `lps[i]`: íŒ¨í„´ Pì˜ [0...i] êµ¬ê°„ì—ì„œ, **ì ‘ë‘ì‚¬ == ì ‘ë¯¸ì‚¬**ì˜ ìµœëŒ€ ê¸¸ì´

#### ì˜ˆì‹œ:

```
P = a b a b a c

i    : 0 1 2 3 4 5
lps  : 0 0 1 2 3 0
```

#### ì˜ë¯¸:

- `lps[4] = 3` â†’ `abab`ì˜ ì ‘ë‘ì‚¬/ì ‘ë¯¸ì‚¬ ê³µí†µ ê¸¸ì´ëŠ” `aba`

### ğŸ”§ LPS ë°°ì—´ êµ¬ì„± ì½”ë“œ

```
vector<int> computeLPS(string P) {
    int M = P.length();
    vector<int> lps(M, 0);
    int len = 0; // ì´ì „ ì ‘ë‘ì‚¬ ê¸¸ì´

    for (int i = 1; i < M; ++i) {
        while (len > 0 && P[i] != P[len])
            len = lps[len - 1];

        if (P[i] == P[len]) lps[i] = ++len;
    }
    return lps;
}
```

### ğŸ” ê²€ìƒ‰ ë‹¨ê³„

1. `i=0`, `j=0`ë¶€í„° ì‹œì‘
2. `T[i] == P[j]` â†’ ë‘˜ ë‹¤ ì¦ê°€
3. `T[i] â‰  P[j]` â†’ `j = lps[j-1]`ë¡œ ì í”„
4. `j == M` â†’ íŒ¨í„´ ì „ì²´ ì¼ì¹˜ â†’ ìœ„ì¹˜ ê¸°ë¡

### ğŸ”§ ì „ì²´ KMP ê²€ìƒ‰ ì½”ë“œ (C++)

```
vector<int> kmpSearch(string T, string P) {
    vector<int> lps = computeLPS(P);
    vector<int> matches;
    int i = 0, j = 0;
    int N = T.size(), M = P.size();

    while (i < N) {
        if (T[i] == P[j]) {
            i++; j++;
        }

        if (j == M) {
            matches.push_back(i - j);
            j = lps[j - 1]; // ë‹¤ìŒ ê²€ìƒ‰
        } else if (i < N && T[i] != P[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }

    return matches;
}
```

### â±ï¸ ì‹œê°„ ë³µì¡ë„

| ë‹¨ê³„       | ë³µì¡ë„       |
| ---------- | ------------ |
| LPS ì „ì²˜ë¦¬ | O(M)         |
| ê²€ìƒ‰       | O(N)         |
| ì „ì²´       | **O(N + M)** |

â†’ ë¬¸ìì—´ ì „ì²´ ê¸¸ì´ì— ë¹„ë¡€í•œ **ì„ í˜• ì‹œê°„ ê²€ìƒ‰**

### ğŸ“š KMP ì•Œê³ ë¦¬ì¦˜ì˜ í™œìš© ë¶„ì•¼

| ë¶„ì•¼                    | ì„¤ëª…                       |
| ----------------------- | -------------------------- |
| í…ìŠ¤íŠ¸ ì—ë””í„° ê²€ìƒ‰ ê¸°ëŠ¥ | ë¹ ë¥¸ ë¬¸ìì—´ ì°¾ê¸°           |
| DNA ì„œì—´ ë¶„ì„           | ìœ ì „ì ì„œì—´ ë¶€ë¶„ ë§¤ì¹­      |
| ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ê²€ì‚¬      | íŠ¹ì • ë¬¸ìì—´ í¬í•¨ ì—¬ë¶€ ê²€ì‚¬ |
| ë¡œê·¸ ë¶„ì„, í•„í„°ë§       | íŒ¨í„´ ì¼ì¹˜ í•„í„°ë§           |
| ë°˜ë³µ íŒ¨í„´ íƒì§€          | `ababab` ê°™ì€ ê·œì¹™ íƒìƒ‰    |

### ğŸ’¬ ì¸í„°ë·°/ì‹œí—˜ ì§ˆë¬¸

- KMPì™€ ë¸Œë£¨íŠ¸í¬ìŠ¤ ë°©ì‹ì˜ ì°¨ì´ëŠ”?
- LPS ë°°ì—´ì˜ ì˜ë¯¸ëŠ”?
- KMPê°€ O(NM)ìœ¼ë¡œ ëŠë ¤ì§ˆ ìˆ˜ ìˆë‚˜?
- KMPì—ì„œ ì—­ë°©í–¥ ê²€ìƒ‰ì€ ê°€ëŠ¥í•œê°€?

### âœ… ì •ë¦¬ ìš”ì•½

| í•­ëª©          | ì„¤ëª…                                   |
| ------------- | -------------------------------------- |
| ëª©í‘œ          | í…ìŠ¤íŠ¸ Tì—ì„œ íŒ¨í„´ Pë¥¼ ì„ í˜• ì‹œê°„ì— ì°¾ê¸° |
| í•µì‹¬ êµ¬ì¡°     | LPS ë°°ì—´ (ì ‘ë‘ì‚¬ = ì ‘ë¯¸ì‚¬ ê¸¸ì´)        |
| ì•Œê³ ë¦¬ì¦˜ íë¦„ | ì „ì²˜ë¦¬ â†’ ê²€ìƒ‰ (ì í”„)                   |
| ì‹œê°„ë³µì¡ë„    | O(N + M)                               |
| ì£¼ìš” íŠ¹ì§•     | í…ìŠ¤íŠ¸ ì¬íƒìƒ‰ ì—†ìŒ, ê³µê°„ íš¨ìœ¨ì         |

## Z-Algorithm

### ğŸ“Œ 1. ë¬¸ì œ ì •ì˜

**ì£¼ì–´ì§„ ë¬¸ìì—´ `S`ì— ëŒ€í•´, ê° ìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ëŠ” ì ‘ë¯¸ì‚¬ê°€ ì–¼ë§ˆë‚˜ ì•ì—ì„œì™€ ì¼ì¹˜í•˜ëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë°°ì—´ Zë¥¼ ê³„ì‚°í•˜ë¼.**

- `Z[i]`: ë¬¸ìì—´ `S[i:]`ì™€ `S[0:]`ì´ ëª‡ ê¸€ìë‚˜ ì¼ì¹˜í•˜ëŠ”ê°€?

```
S = a b a b a c a b a b a b
Z = 0 0 1 0 3 0 1 0 5 0 1 0
```

### ğŸ§  2. í•µì‹¬ ê°œë…

- `Z[0]`ì€ ì˜ë¯¸ ì—†ìŒ (ë³´í†µ 0ìœ¼ë¡œ ì •ì˜)
- Z-ë°°ì—´ì€ **Sì—ì„œì˜ ê° ìœ„ì¹˜ ië¶€í„° ì‹œì‘í•œ ì ‘ë¯¸ì‚¬ì™€ S[0:]ì˜ ìµœëŒ€ ì¼ì¹˜ ê¸¸ì´**ë¥¼ ì˜ë¯¸

> Z[i] = max k such that S[0:k] == S[i:i+k]

### ğŸ’¡ 3. Zë°°ì—´ë¡œ ê°€ëŠ¥í•œ ì¼

| í™œìš©                             | ì„¤ëª…                                          |
| -------------------------------- | --------------------------------------------- |
| ë¬¸ìì—´ ê²€ìƒ‰                      | `P + "$" + T`ë¥¼ ë§Œë“¤ì–´ Zë°°ì—´ë¡œ ì¼ì¹˜ ìœ„ì¹˜ íƒìƒ‰ |
| ë°˜ë³µ íŒ¨í„´ íƒì§€                   | Z[i] + i == N â†’ íŒ¨í„´ ì „ì²´ ë°˜ë³µ                |
| ë¬¸ìì—´ì˜ ì ‘ë‘ì‚¬/ì ‘ë¯¸ì‚¬ êµ¬ì¡° ë¶„ì„ | ì ‘ë‘ì‚¬ë¡œë„ ì“°ì´ëŠ” ì ‘ë¯¸ì‚¬ íƒì§€                 |

### ğŸ“¦ 4. Zë°°ì—´ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜

> **[l, r]** êµ¬ê°„ì„ ìœ ì§€í•˜ë©´ì„œ, í˜„ì¬ ìœ„ì¹˜ `i`ê°€ ê·¸ ì•ˆì— ìˆë‹¤ë©´ ê¸°ì¡´ ê°’ì„ ì¬í™œìš©
>  â†’ `O(N)`ì— ê³„ì‚° ê°€ëŠ¥

#### âœ… ì½”ë“œ (C++)

```
vector<int> getZ(string s) {
    int n = s.size();
    vector<int> Z(n);
    int l = 0, r = 0;

    for (int i = 1; i < n; ++i) {
        if (i <= r)
            Z[i] = min(r - i + 1, Z[i - l]);

        while (i + Z[i] < n && s[Z[i]] == s[i + Z[i]])
            Z[i]++;

        if (i + Z[i] - 1 > r) {
            l = i;
            r = i + Z[i] - 1;
        }
    }
    return Z;
}
```

### ğŸ§ª 5. ë¬¸ìì—´ ê²€ìƒ‰ (íŒ¨í„´ ì°¾ê¸°)

```
P = abab
T = abababab

â†’ S = P + "$" + T = abab$abababab
â†’ Zë°°ì—´ ê³„ì‚° í›„ Z[i] == P.length() ì¸ ì§€ì ì´ ë§¤ì¹­ ì§€ì 
```

```
vector<int> search(string P, string T) {
    string S = P + "$" + T;
    vector<int> Z = getZ(S);
    vector<int> matches;
    int lenP = P.size();

    for (int i = lenP + 1; i < S.size(); ++i) {
        if (Z[i] == lenP)
            matches.push_back(i - lenP - 1);
    }
    return matches;
}
```

### â±ï¸ 6. ì‹œê°„ ë³µì¡ë„

| ì—°ì‚°        | ì‹œê°„ë³µì¡ë„                   |
| ----------- | ---------------------------- |
| Zë°°ì—´ ê³„ì‚°  | **O(N)**                     |
| ë¬¸ìì—´ ê²€ìƒ‰ | **O(N + M)** (íŒ¨í„´ + í…ìŠ¤íŠ¸) |

### ğŸ“š 7. Z vs KMP

| í•­ëª©          | KMP                   | Z ì•Œê³ ë¦¬ì¦˜                    |
| ------------- | --------------------- | ----------------------------- |
| í•µì‹¬ ìë£Œêµ¬ì¡° | LPS ë°°ì—´              | Z ë°°ì—´                        |
| ë¹„êµ ê¸°ì¤€     | íŒ¨í„´ ë‚´ì˜ ì ‘ë‘ì‚¬ ì¼ì¹˜ | **ë¬¸ìì—´ ì „ì²´ì˜ ì ‘ë‘ì‚¬ ì¼ì¹˜** |
| ì „ì²˜ë¦¬ ëŒ€ìƒ   | íŒ¨í„´(P)ë§Œ             | íŒ¨í„´ + í…ìŠ¤íŠ¸ (í•©ì¹œ ë¬¸ìì—´)   |
| ì‚¬ìš© íŒ¨í„´     | ë¶€ë¶„ì¼ì¹˜ ì í”„ìš©       | ì ‘ë‘ì‚¬ ë¶„ì„, ì¼ì¹˜ ì§€ì  íŒŒì•…   |
| ì½”ë“œ ë³µì¡ë„   | ì•½ê°„ ë³µì¡             | ë” ì§ê´€ì                      |

### ğŸ§  8. ì‹¤ì „ í™œìš© ì˜ˆì‹œ

| ë¬¸ì œ ìœ í˜•                     | Z í™œìš©               |
| ----------------------------- | -------------------- |
| íŒ¨í„´ ì¼ì¹˜ ê²€ìƒ‰                | âœ…                    |
| ë¬¸ìì—´ ì••ì¶•/ë°˜ë³µ íƒì§€         | âœ…                    |
| ì ‘ë‘ì‚¬ì™€ ì ‘ë¯¸ì‚¬ ê´€ê³„          | âœ…                    |
| ì—¬ëŸ¬ íŒ¨í„´ ê²€ìƒ‰ (Aho-Corasick) | âŒ ë‹¤ë¥¸ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš© |

### ğŸ’¬ ì¸í„°ë·° ì§ˆë¬¸

- Z[i]ê°€ ì˜ë¯¸í•˜ëŠ” ê²ƒì€?
- Zë°°ì—´ì„ ì–´ë–»ê²Œ O(N)ì— ê³„ì‚°í•  ìˆ˜ ìˆë‚˜?
- KMPì™€ Zì˜ ì°¨ì´ì ì€?
- ë¬¸ìì—´ Tì—ì„œ Pê°€ ë“±ì¥í•˜ëŠ” ëª¨ë“  ìœ„ì¹˜ë¥¼ Zë¥¼ ì´ìš©í•´ êµ¬í•˜ëŠ” ë°©ë²•ì€?

### âœ… ì •ë¦¬ ìš”ì•½

| í•­ëª©       | ì„¤ëª…                                         |
| ---------- | -------------------------------------------- |
| Z[i]       | S[0:]ì™€ S[i:]ì˜ ì ‘ë‘ì‚¬ ì¼ì¹˜ ê¸¸ì´             |
| ëª©ì        | ë¬¸ìì—´ ì¼ì¹˜, ë°˜ë³µ ë¶„ì„                       |
| ì‹œê°„ë³µì¡ë„ | O(N)                                         |
| ì£¼ìš” ì‘ìš©  | ë¬¸ìì—´ ê²€ìƒ‰, ë°˜ë³µ íŒ¨í„´ íƒì§€                  |
| ì¥ì        | KMPë³´ë‹¤ ê°„ë‹¨í•œ êµ¬í˜„, ë‹¤ì–‘í•œ ì ‘ë‘ì‚¬ ì‘ìš© ê°€ëŠ¥ |

## Suffix Array / Suffix Tree

### ğŸ“Œ 1. í•µì‹¬ ê°œë…

| ê°œë…             | ì„¤ëª…                                                         |
| ---------------- | ------------------------------------------------------------ |
| **Suffix**       | ë¬¸ìì—´ì˜ ì ‘ë¯¸ì‚¬. ì˜ˆ: `banana`ì˜ suffixëŠ” `banana`, `anana`, `nana`, `ana`, `na`, `a` |
| **Suffix Array** | ëª¨ë“  ì ‘ë¯¸ì‚¬ë¥¼ **ì‚¬ì „ìˆœ ì •ë ¬í•œ ì¸ë±ìŠ¤ ë°°ì—´**                  |
| **Suffix Tree**  | ëª¨ë“  ì ‘ë¯¸ì‚¬ë¥¼ **ì••ì¶•ëœ Trie í˜•íƒœ**ë¡œ ì €ì¥í•œ íŠ¸ë¦¬ êµ¬ì¡°        |

### ğŸ“¦ Suffix Array (ì ‘ë¯¸ì‚¬ ë°°ì—´)

#### ğŸ” ì •ì˜

**Suffix Array**ëŠ” ë¬¸ìì—´ì˜ ëª¨ë“  ì ‘ë¯¸ì‚¬ë¥¼ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬í•œ í›„,
 ê·¸ **ì‹œì‘ ì¸ë±ìŠ¤ë§Œ ë°°ì—´ í˜•íƒœë¡œ ì €ì¥**í•œ ìë£Œêµ¬ì¡°

#### ì˜ˆì‹œ:

```
S = banana

Suffixes (with index):
0: banana
1: anana
2: nana
3: ana
4: na
5: a

ì‚¬ì „ìˆœ ì •ë ¬:
a       â†’ 5  
ana     â†’ 3  
anana   â†’ 1  
banana  â†’ 0  
na      â†’ 4  
nana    â†’ 2  

Suffix Array = [5, 3, 1, 0, 4, 2]
```

### ğŸ”§ ì‹œê°„ë³µì¡ë„

| ì•Œê³ ë¦¬ì¦˜         | ë³µì¡ë„        |
| ---------------- | ------------- |
| naive (ì •ë ¬)     | O(nÂ² log n)   |
| **Doubling**     | O(n logÂ² n)   |
| **Skew / SA-IS** | O(n) (ì´ë¡ ìƒ) |

### âš¡ ì£¼ìš” í™œìš©

| ë¬¸ì œ/ê¸°ëŠ¥            | ì„¤ëª…                                |
| -------------------- | ----------------------------------- |
| ì„œë¸ŒìŠ¤íŠ¸ë§ ì¡´ì¬ í™•ì¸ | ì´ì§„ íƒìƒ‰ìœ¼ë¡œ `O(log n)`            |
| kë²ˆì§¸ ì‚¬ì „ìˆœ ì ‘ë¯¸ì‚¬  | SA[k] í™•ì¸                          |
| **LCP ë°°ì—´** ìƒì„±    | ì¸ì ‘ ì ‘ë¯¸ì‚¬ì˜ ê³µí†µ ì ‘ë‘ì‚¬ ê¸¸ì´ ì €ì¥ |
| ë°˜ë³µ íŒ¨í„´ íƒì§€       | LCP ë°°ì—´ë¡œ ì°¾ìŒ                     |
| ì‚¬ì „ìˆœ ìˆœì„œ ë¹„êµ     | SAë¡œ ì²˜ë¦¬ ê°€ëŠ¥                      |

### ğŸ§  LCP ë°°ì—´ (Longest Common Prefix)

- LCP[i] = `SA[i]`ì™€ `SA[i-1]`ì˜ ì ‘ë‘ì‚¬ ê³µí†µ ê¸¸ì´

```
S = banana
SA = [5, 3, 1, 0, 4, 2]
Suffixes:
a
ana
anana
banana
na
nana

LCP = [_, 1, 3, 0, 0, 2]
```

### ğŸŒ³ Suffix Tree (ì ‘ë¯¸ì‚¬ íŠ¸ë¦¬)

#### ğŸ“Œ ì •ì˜

**Suffix Tree**ëŠ” ë¬¸ìì—´ì˜ ëª¨ë“  ì ‘ë¯¸ì‚¬ë¥¼ Trie(ì ‘ë‘ì‚¬ íŠ¸ë¦¬)ë¡œ êµ¬ì„±í•œ êµ¬ì¡°ì—ì„œ
 **ì—°ì†ëœ ë¬¸ìë“¤ì„ ì••ì¶•í•˜ì—¬ ê³µê°„ì„ ì¤„ì¸** ìë£Œêµ¬ì¡°.

> ì ‘ë¯¸ì‚¬ íŠ¸ë¦¬ = ë¬¸ìì—´ ê²€ìƒ‰ìš© Trieì˜ ìµœì í™”ëœ ì••ì¶•íŒ

#### ğŸŒ¿ êµ¬ì¡° ì˜ˆì‹œ (S = banana$)

```
íŠ¸ë¦¬ êµ¬ì¡° (ê°„ë‹¨íˆ í‘œí˜„):

root
 â”œâ”€ b â†’ a â†’ n â†’ a â†’ n â†’ a â†’ $
 â”œâ”€ a â†’ n â†’ a â†’ n â†’ a â†’ $
 â”œâ”€ n â†’ a â†’ n â†’ a â†’ $
 ...
```

- ê° ë¦¬í”„ëŠ” ì ‘ë¯¸ì‚¬ì˜ ì‹œì‘ ì¸ë±ìŠ¤ë¥¼ ê°€ì§
- ë‚´ë¶€ ë…¸ë“œëŠ” ê³µí†µ ì ‘ë‘ì‚¬ë¥¼ í‘œí˜„

### ğŸ”§ ì‹œê°„ë³µì¡ë„

| ì‘ì—…                | ë³µì¡ë„                       |
| ------------------- | ---------------------------- |
| íŠ¸ë¦¬ ìƒì„±           | O(n) (Ukkonen ì•Œê³ ë¦¬ì¦˜ ê¸°ì¤€) |
| ì„œë¸ŒìŠ¤íŠ¸ë§ ê²€ìƒ‰     | O(m) (mì€ íŒ¨í„´ ê¸¸ì´)         |
| LCP, longest repeat | O(n)                         |
| kë²ˆì§¸ ì ‘ë¯¸ì‚¬ ê²€ìƒ‰   | O(k)                         |

### âš ï¸ ê³µê°„ ì°¨ì´

| êµ¬ì¡°         | ê³µê°„                   |
| ------------ | ---------------------- |
| Suffix Array | O(n) (ì‘ìŒ)            |
| Suffix Tree  | O(n)~O(n log n) (ë§ìŒ) |

Suffix ArrayëŠ” ë©”ëª¨ë¦¬ ì ê³ , êµ¬í˜„ ê°„ë‹¨
 Suffix TreeëŠ” ë©”ëª¨ë¦¬ í¬ì§€ë§Œ ì„œë¸ŒìŠ¤íŠ¸ë§ êµ¬ì¡° íŒŒì•…ì— ê°•ë ¥

### ğŸ†š Suffix Array vs Suffix Tree

| í•­ëª©             | Suffix Array           | Suffix Tree                    |
| ---------------- | ---------------------- | ------------------------------ |
| ì €ì¥ ì •ë³´        | ì ‘ë¯¸ì‚¬ ì‹œì‘ ì¸ë±ìŠ¤     | ë¬¸ì ê²½ë¡œë¡œ í‘œí˜„í•œ ì ‘ë¯¸ì‚¬ íŠ¸ë¦¬ |
| ê³µê°„             | ì ìŒ (O(n))            | í¼ (O(n log n))                |
| êµ¬í˜„ ë‚œì´ë„      | ë³´í†µ                   | ë§¤ìš° ì–´ë ¤ì›€ (Ukkonen ë“±)       |
| ê²€ìƒ‰ ì†ë„        | O(m log n) (ì´ì§„ íƒìƒ‰) | O(m)                           |
| ë°˜ë³µ íŒ¨í„´ ë¶„ì„   | LCP ë°°ì—´ë¡œ ê°€ëŠ¥        | ë” ì§ê´€ì                       |
| ì‚¬ì „ìˆœ ìˆœì„œ í™•ì¸ | ì¦‰ì‹œ ê°€ëŠ¥              | ë³µì¡í•¨                         |

### ğŸ“š í™œìš© ë¶„ì•¼

| ë¶„ì•¼            | í™œìš©                                  |
| --------------- | ------------------------------------- |
| ì„œë¸ŒìŠ¤íŠ¸ë§ ê²€ìƒ‰ | íŒ¨í„´ í¬í•¨ ì—¬ë¶€ (`abc` in `banana`)    |
| ì‚¬ì „ìˆœ ë¹„êµ     | ì ‘ë¯¸ì‚¬ ì •ë ¬ ë¬¸ì œ, kë²ˆì§¸ ì‚¬ì „ìˆœ ì ‘ë¯¸ì‚¬ |
| LCP ê¸°ë°˜ ë¬¸ì œ   | ë°˜ë³µ, íšŒë¬¸, ìœ ì‚¬ ë¬¸ìì—´ ë¶„ì„          |
| ì••ì¶•            | LZ77, BWT ë“±                          |
| ìœ ì „ì²´ ë¶„ì„     | DNA ì„œì—´ íŒ¨í„´ ì¶”ì¶œ                    |

### âœ… ì •ë¦¬ ìš”ì•½

| ê°œë…         | ì„¤ëª…                                    |
| ------------ | --------------------------------------- |
| Suffix Array | ë¬¸ìì—´ ì ‘ë¯¸ì‚¬ë¥¼ ì •ë ¬í•œ ì¸ë±ìŠ¤ ë°°ì—´      |
| Suffix Tree  | ì ‘ë¯¸ì‚¬ë¥¼ íŠ¸ë¦¬ë¡œ í‘œí˜„í•œ ì••ì¶•ëœ Trie êµ¬ì¡° |
| ì‹œê°„ë³µì¡ë„   | O(n logÂ² n) / O(n) ìƒì„± ê°€ëŠ¥            |
| ìš©ë„         | ê²€ìƒ‰, ë°˜ë³µ íŒ¨í„´, ì••ì¶• ë“±                |
| ì£¼ì˜         | TreeëŠ” êµ¬í˜„/ë©”ëª¨ë¦¬ ë¶€ë‹´ í¼              |

## Aho-Corasick ìë™í™”

### ğŸ“Œ 1. ë¬¸ì œ ì •ì˜

> **íŒ¨í„´ ì§‘í•© {Pâ‚, Pâ‚‚, ..., Pâ‚–}ì™€ í…ìŠ¤íŠ¸ Tê°€ ì£¼ì–´ì¡Œì„ ë•Œ,**
>  **ëª¨ë“  íŒ¨í„´ì˜ ë“±ì¥ ìœ„ì¹˜ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì°¾ì•„ë¼.**

### ğŸ§  2. í•µì‹¬ ì•„ì´ë””ì–´

Aho-CorasickëŠ” ë‹¤ìŒ 3ê°€ì§€ë¥¼ ê²°í•©í•œ êµ¬ì¡°ì•¼:

| êµ¬ì¡°         | ì„¤ëª…                                          |
| ------------ | --------------------------------------------- |
| Trie         | ì—¬ëŸ¬ íŒ¨í„´ì„ ê³µí†µ ì ‘ë‘ì‚¬ êµ¬ì¡°ë¡œ í‘œí˜„           |
| Failure ë§í¬ | KMPì²˜ëŸ¼ ì‹¤íŒ¨ ì‹œ ë‹¤ìŒìœ¼ë¡œ ì í”„í•  ìœ„ì¹˜          |
| Output ë§í¬  | í˜„ì¬ ë…¸ë“œì—ì„œ ëë‚˜ëŠ”(ë˜ëŠ” í¬í•¨ëœ) íŒ¨í„´ ë¦¬ìŠ¤íŠ¸ |

### ğŸ—ï¸ 3ë‹¨ê³„ êµ¬ì„±

#### âœ… 1ë‹¨ê³„: Trie ìƒì„±

- ëª¨ë“  íŒ¨í„´ ë¬¸ìì—´ì„ Trieì— ì‚½ì…
- ê° ë…¸ë“œëŠ” ë¬¸ì, ìì‹, isEnd ì†ì„±ì„ ê°€ì§

#### âœ… 2ë‹¨ê³„: Failure ë§í¬ êµ¬ì„± (BFS)

- ì‹¤íŒ¨ ì‹œ ëŒì•„ê°ˆ ë…¸ë“œ ì§€ì • (ì ‘ë‘ì‚¬ ì¼ì¹˜ ì‹¤íŒ¨ ì‹œ KMPì²˜ëŸ¼)
- ë£¨íŠ¸ì˜ ìì‹ì€ ì‹¤íŒ¨ ë§í¬ê°€ ë£¨íŠ¸
- ë‚´ë¶€ ë…¸ë“œëŠ” ë¶€ëª¨ì˜ ì‹¤íŒ¨ ë§í¬ + ìê¸° ê¸€ìë¡œ ì—°ê²°ëœ ë…¸ë“œ

#### âœ… 3ë‹¨ê³„: í…ìŠ¤íŠ¸ ê²€ìƒ‰

- ë¬¸ìë¥¼ ë”°ë¼ ì´ë™í•˜ë©°,
- ë§¤ì¹­ë˜ì§€ ì•Šìœ¼ë©´ ì‹¤íŒ¨ ë§í¬ ë”°ë¼ ì´ë™
- ì¼ì¹˜ ë…¸ë“œë§ˆë‹¤ output ë¦¬ìŠ¤íŠ¸ í™•ì¸ â†’ ì •ë‹µ ê¸°ë¡

### ğŸ”§ C++ ìŠ¤íƒ€ì¼ ì˜ˆì œ ì½”ë“œ (ê°„ë‹¨ ë²„ì „)

```
struct TrieNode {
    TrieNode* next[26] = {};
    TrieNode* fail = nullptr;
    vector<int> output;  // ì¼ì¹˜í•œ íŒ¨í„´ ì¸ë±ìŠ¤ë“¤
};

TrieNode* root = new TrieNode();

void insert(const string& word, int idx) {
    TrieNode* node = root;
    for (char c : word) {
        int x = c - 'a';
        if (!node->next[x]) node->next[x] = new TrieNode();
        node = node->next[x];
    }
    node->output.push_back(idx);
}
```

#### ğŸ” Failure ë§í¬ êµ¬ì„±

```
void buildFailureLinks() {
    queue<TrieNode*> q;
    root->fail = root;
    for (int c = 0; c < 26; ++c) {
        if (root->next[c]) {
            root->next[c]->fail = root;
            q.push(root->next[c]);
        } else {
            root->next[c] = root;  // íŠ¸ë¦­: ì—†ëŠ” ê²½ìš° ë£¨íŠ¸ë¡œ ì—°ê²°
        }
    }

    while (!q.empty()) {
        TrieNode* cur = q.front(); q.pop();
        for (int c = 0; c < 26; ++c) {
            TrieNode* child = cur->next[c];
            if (!child) continue;

            TrieNode* f = cur->fail;
            while (!f->next[c]) f = f->fail;
            child->fail = f->next[c];

            // fail ê²½ë¡œ ë”°ë¼ê°€ë©° outputë„ ì´ì–´ë°›ê¸°
            child->output.insert(
                child->output.end(),
                child->fail->output.begin(),
                child->fail->output.end()
            );

            q.push(child);
        }
    }
}
```

#### ğŸ” í…ìŠ¤íŠ¸ ê²€ìƒ‰

```
void search(const string& text, vector<vector<int>>& matchPos) {
    TrieNode* node = root;
    for (int i = 0; i < text.size(); ++i) {
        int x = text[i] - 'a';
        while (!node->next[x]) node = node->fail;
        node = node->next[x];
        for (int patIdx : node->output)
            matchPos[patIdx].push_back(i);  // ìœ„ì¹˜ ê¸°ë¡
    }
}
```

### â±ï¸ ì‹œê°„ ë³µì¡ë„

| ë‹¨ê³„         | ì‹œê°„                                |
| ------------ | ----------------------------------- |
| Trie êµ¬ì„±    | O(Î£ íŒ¨í„´ ê¸¸ì´)                      |
| Failure ë§í¬ | O(Î£ íŒ¨í„´ ê¸¸ì´)                      |
| í…ìŠ¤íŠ¸ íƒìƒ‰  | O(N + ì´ ë§¤ì¹­ ìˆ˜) (N = í…ìŠ¤íŠ¸ ê¸¸ì´) |

### ğŸ“š ì‹¤ì „ ë¬¸ì œ ì˜ˆì‹œ

| ìœ í˜•                              | ì„¤ëª… |
| --------------------------------- | ---- |
| ë‹¤ìˆ˜ í‚¤ì›Œë“œ íƒìƒ‰ (`in` ì¿¼ë¦¬)      | âœ…    |
| ê¸ˆì§€ ë‹¨ì–´ í•„í„°ë§ (`bad words`)    | âœ…    |
| ë°”ì´ëŸ¬ìŠ¤ ì„œëª… íƒìƒ‰                | âœ…    |
| ìŠ¤íŒ¸ íƒì§€, ì¹¨í•´ íƒì§€ ì‹œìŠ¤í…œ(NIDS) | âœ…    |
| íŒ¨í„´ ì¼ì¹˜ ê°œìˆ˜/ìœ„ì¹˜ ì°¾ê¸°          | âœ…    |

### ğŸ†š Aho-Corasick vs KMP/Z

| í•­ëª©        | Aho-Corasick        | KMP / Z        |
| ----------- | ------------------- | -------------- |
| íŒ¨í„´ ìˆ˜     | ìˆ˜ì²œ ê°œ ì´ìƒ ê°€ëŠ¥   | ë³´í†µ 1ê°œ       |
| ì „ì²˜ë¦¬ ëŒ€ìƒ | ëª¨ë“  íŒ¨í„´           | ë‹¨ì¼ íŒ¨í„´      |
| íƒìƒ‰ ëŒ€ìƒ   | ì „ì²´ í…ìŠ¤íŠ¸         | ì „ì²´ í…ìŠ¤íŠ¸    |
| ì„±ëŠ¥        | O(N + ì´ íŒ¨í„´ ê¸¸ì´) | O(N + M)       |
| ì‚¬ìš© ìƒí™©   | ë‹¤ì¤‘ ê²€ìƒ‰ í•„ìš” ì‹œ   | ë‹¨ì¼ íŒ¨í„´ ê²€ìƒ‰ |

### âœ… ì •ë¦¬ ìš”ì•½

| í•­ëª©       | ì„¤ëª…                                          |
| ---------- | --------------------------------------------- |
| ëª©ì        | **ë‹¤ìˆ˜ì˜ ë¬¸ìì—´ íŒ¨í„´ì„ ë™ì‹œì— ê²€ìƒ‰**          |
| êµ¬ì¡°       | Trie + Failure Link                           |
| ì‹œê°„ë³µì¡ë„ | O(N + ì´ íŒ¨í„´ ê¸¸ì´ + ë§¤ì¹­ ìˆ˜)                 |
| íŠ¹ì§•       | ì„ í˜• ì‹œê°„, íŠ¸ë¦¬ ê¸°ë°˜ ìë™í™”                   |
| ì£¼ìš” í™œìš©  | ê²€ìƒ‰ ì—”ì§„, ê¸ˆì§€ì–´ íƒì§€, ë°”ì´ëŸ¬ìŠ¤ íŒ¨í„´ íƒì§€ ë“± |

# 3.4 ìˆ˜í•™ì  ì•Œê³ ë¦¬ì¦˜

## ì†Œìˆ˜ íŒë³„ ë° ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´

### ğŸ“Œ 1. ì†Œìˆ˜(Prime Number)ë€?

> 1ë³´ë‹¤ í° ìì—°ìˆ˜ ì¤‘ì—ì„œ, **1ê³¼ ìê¸° ìì‹ ë§Œì„ ì•½ìˆ˜ë¡œ ê°€ì§€ëŠ” ìˆ˜**

- ì˜ˆ: 2, 3, 5, 7, 11, 13, ...
- 1ì€ ì†Œìˆ˜ê°€ ì•„ë‹˜
- 2ëŠ” ìœ ì¼í•œ ì§ìˆ˜ ì†Œìˆ˜

### âœ… 2. ì†Œìˆ˜ íŒë³„ (Primality Test)

#### ë°©ë²• 1: ì¼ë°˜ ì†Œìˆ˜ íŒë³„ (Trial Division)

```
bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i <= n; ++i)
        if (n % i == 0) return false;
    return true;
}
```

- **ì‹œê°„ë³µì¡ë„**: O(âˆšn)
- **íŠ¹ì§•**: ê°„ë‹¨í•˜ê³  ë²”ìš©

#### ë°©ë²• 2: 6k Â± 1 ìµœì í™”

- ì†Œìˆ˜ëŠ” ëŒ€ë¶€ë¶„ `6k Â± 1` í˜•íƒœì´ë¯€ë¡œ, 2ì™€ 3ì€ ë¯¸ë¦¬ ì œì™¸ í›„, 6ì”© ê±´ë„ˆë›°ë©° ê²€ì‚¬

```
bool isPrime(int n) {
    if (n < 2) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (int i = 5; i * i <= n; i += 6)
        if (n % i == 0 || n % (i + 2) == 0) return false;
    return true;
}
```

### ğŸ§  3. ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ (Sieve of Eratosthenes)

> **1ë¶€í„° Nê¹Œì§€ì˜ ëª¨ë“  ì†Œìˆ˜ë¥¼ êµ¬í•˜ëŠ” ê°€ì¥ ëŒ€í‘œì ì¸ ì•Œê³ ë¦¬ì¦˜**

#### ğŸ—ï¸ ì•Œê³ ë¦¬ì¦˜ ì›ë¦¬

1. 2ë¶€í„° Nê¹Œì§€ ë°°ì—´ì„ ë§Œë“ ë‹¤
2. 2ë¶€í„° ì‹œì‘í•´ì„œ **ìê¸° ë°°ìˆ˜ë¥¼ ëª¨ë‘ ì§€ì›€**
3. ë‚¨ì€ ìˆ˜ëŠ” ëª¨ë‘ ì†Œìˆ˜

#### âœ… ì½”ë“œ (C++)

```
vector<bool> isPrime(int N) {
    vector<bool> prime(N + 1, true);
    prime[0] = prime[1] = false;

    for (int i = 2; i * i <= N; ++i) {
        if (!prime[i]) continue;
        for (int j = i * i; j <= N; j += i)
            prime[j] = false;
    }
    return prime;
}
```

#### ğŸ§® ì‹œê°„ë³µì¡ë„

- **O(N log log N)**
- ë§¤ìš° ë¹ ë¦„, `10^7` ì´í•˜ ë²”ìœ„ëŠ” ê±°ì˜ ì‹¤ì‹œê°„ ì²˜ë¦¬ ê°€ëŠ¥

### ğŸ’¡ í™•ì¥: ì†Œì¸ìˆ˜ ë¶„í•´ìš© ìµœì†Œ ì†Œì¸ìˆ˜ í…Œì´ë¸”

```
vector<int> minFactor(N + 1);

void sieveMinFactor(int N) {
    for (int i = 2; i <= N; ++i) {
        if (minFactor[i] == 0) {
            for (int j = i; j <= N; j += i)
                if (minFactor[j] == 0)
                    minFactor[j] = i;
        }
    }
}
```

> `minFactor[n]`ì„ ì´ìš©í•´ O(log n)ì— ì†Œì¸ìˆ˜ ë¶„í•´ ê°€ëŠ¥

### ğŸ§  ì‹¤ì œ ë¬¸ì œ í™œìš© ì˜ˆì‹œ

| ë¬¸ì œ ìœ í˜•              | ì†Œìˆ˜ íŒë³„ | ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤     |
| ---------------------- | --------- | ------------------ |
| ë‹¨ì¼ ìˆ«ì íŒë³„         | âœ…         | âŒ                  |
| êµ¬ê°„ ë‚´ ëª¨ë“  ì†Œìˆ˜ ì¶œë ¥ | âŒ         | âœ…                  |
| ì†Œì¸ìˆ˜ ë¶„í•´            | âŒ         | âœ… (with minFactor) |
| ê³¨ë“œë°”í ì¶”ì¸¡          | âœ…         | âœ…                  |
| ì†Œìˆ˜ì˜ ì¡°í•©, ìŒ íŒë³„   | âœ…         | âœ…                  |

### ğŸ§ª ì˜ˆì œ ë¬¸ì œ (BOJ ê¸°ì¤€)

| ë¬¸ì œ ì´ë¦„           | ë²ˆí˜¸ | ê´€ë ¨ ì•Œê³ ë¦¬ì¦˜ |
| ------------------- | ---- | ------------- |
| ì†Œìˆ˜ ì°¾ê¸°           | 1978 | ì†Œìˆ˜ íŒë³„     |
| ê³¨ë“œë°”íì˜ ì¶”ì¸¡     | 9020 | ì²´ + íŒë³„     |
| ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ | 2960 | ì²´ êµ¬í˜„       |
| ì†Œìˆ˜ êµ¬í•˜ê¸°         | 1929 | ì²´            |
| ê±°ì˜ ì†Œìˆ˜           | 1456 | ì²´ ë³€í˜•       |

### âœ… ì •ë¦¬ ìš”ì•½

| í•­ëª©        | ì„¤ëª…                                            |
| ----------- | ----------------------------------------------- |
| ì†Œìˆ˜ íŒë³„   | O(âˆšn), ë‹¨ì¼ ìˆ˜ í™•ì¸                             |
| ì²´ ì•Œê³ ë¦¬ì¦˜ | O(n log log n), ë‹¤ìˆ˜ ì†Œìˆ˜ ë¹ ë¥´ê²Œ íƒìƒ‰           |
| í™•ì¥        | ìµœì†Œ ì†Œì¸ìˆ˜, ì¡°í•© íƒìƒ‰, ì†Œìˆ˜ êµ¬ê°„ ì‘ìš©          |
| ì‹¤ì „ ì‚¬ìš©   | ì•”í˜¸í•™, ìˆ˜ë¡  ë¬¸ì œ, ì¡°í•© í•„í„°ë§, ì†Œìˆ˜ ìŒ íƒìƒ‰ ë“± |

## ìµœëŒ€ê³µì•½ìˆ˜(GCD), ìœ í´ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜

### ğŸ“Œ 1. ìµœëŒ€ê³µì•½ìˆ˜(GCD: Greatest Common Divisor)

> ë‘ ìˆ˜ A, Bì˜ ê³µì•½ìˆ˜ ì¤‘ **ê°€ì¥ í° ì •ìˆ˜**

- ì˜ˆ: GCD(12, 18) = 6
- ì„±ì§ˆ:
  - GCD(A, A) = A
  - GCD(A, 0) = A
  - GCD(0, B) = B
  - GCD(A, B) = GCD(B, A)

### ğŸ” 2. ìœ í´ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜

> â€œ**í° ìˆ˜ì—ì„œ ì‘ì€ ìˆ˜ë¥¼ ê³„ì† ë‚˜ëˆ ì„œ** ë‚˜ë¨¸ì§€ê°€ 0ì´ ë  ë•Œì˜ ìˆ˜ê°€ GCDë‹¤.â€

#### ğŸ¯ í•µì‹¬ ê³µì‹:

```
GCD(A, B) = GCD(B, A % B)
```

â†’ Aë¥¼ Bë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ ê³„ì† ëŒ€ì…í•´ ë‚˜ê°€ë‹¤ ë³´ë©´, ì–¸ì  ê°€ëŠ” 0ì´ ë˜ê³ , ê·¸ë•Œì˜ Bê°€ ìµœëŒ€ê³µì•½ìˆ˜!

#### âœ… ë°˜ë³µë¬¸ êµ¬í˜„ (C++)

```
int gcd(int a, int b) {
    while (b != 0) {
        int r = a % b;
        a = b;
        b = r;
    }
    return a;
}
```

#### âœ… ì¬ê·€í˜• êµ¬í˜„

```
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

#### ğŸ“Š ì‹œê°„ë³µì¡ë„

- O(log(max(A, B)))
- ë§¤ìš° ë¹ ë¥´ë©° 64ë¹„íŠ¸ ì •ìˆ˜ë„ ë¬¸ì œ ì—†ìŒ

### â• 3. ìµœì†Œê³µë°°ìˆ˜(LCM)ì™€ì˜ ê´€ê³„

> ë‘ ìˆ˜ì˜ ìµœì†Œê³µë°°ìˆ˜ëŠ” GCDë¥¼ ì´ìš©í•´ì„œ ì‰½ê²Œ êµ¬í•  ìˆ˜ ìˆì–´

#### ê³µì‹:

```
LCM(A, B) = A Ã— B / GCD(A, B)
```

#### ì˜ˆ:

```
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
```

### ğŸ§  4. í™•ì¥ ìœ í´ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜ (Extended Euclidean Algorithm)

> **ax + by = gcd(a, b)** ë¥¼ ë§Œì¡±í•˜ëŠ” ì •ìˆ˜ x, yë¥¼ êµ¬í•œë‹¤

â†’ **ì„ í˜• í•©ë™ ë°©ì •ì‹, ëª¨ë“ˆëŸ¬ ì—­ì›**ì—ì„œ ë§¤ìš° ì¤‘ìš”

#### âœ… êµ¬í˜„ ì˜ˆ:

```
int extendedGCD(int a, int b, int& x, int& y) {
    if (b == 0) { x = 1; y = 0; return a; }
    int x1, y1;
    int g = extendedGCD(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return g;
}
```

- ê²°ê³¼: `ax + by = gcd(a, b)` ë¥¼ ë§Œì¡±í•˜ëŠ” x, y ë°˜í™˜ë¨

### ğŸ“š GCD ì‚¬ìš© ì‹¤ì „ ë¬¸ì œ ì˜ˆì‹œ

| ë¬¸ì œ ìœ í˜•                          | GCD/ìœ í´ë¦¬ë“œ í™œìš©      |
| ---------------------------------- | ---------------------- |
| ìˆ˜ì—´ ì „ì²´ì˜ ìµœëŒ€ê³µì•½ìˆ˜ êµ¬í•˜ê¸°      | âœ… O(N log A)           |
| Aì™€ Bì˜ ìµœì†Œ ê³µë°°ìˆ˜ êµ¬í•˜ê¸°         | âœ… GCDë¡œ LCM ê³„ì‚°       |
| ê¸°ì•½ ë¶„ìˆ˜/ì•½ë¶„ ì²˜ë¦¬                | âœ… ë¶„ì/ë¶„ëª¨ GCD ë‚˜ëˆ„ê¸° |
| ë‚˜ë¨¸ì§€ ì—°ì‚° ì—­ì› (modular inverse) | âœ… í™•ì¥ ìœ í´ë¦¬ë“œ ì´ìš©   |
| ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬ (CRT)         | âœ… ê³„ìˆ˜ì˜ GCD ì‚¬ìš©      |

### ğŸ’¬ ì¸í„°ë·°/ì‹œí—˜ ì§ˆë¬¸

- ìœ í´ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜ì´ ì¢…ë£Œë˜ëŠ” ì´ìœ ëŠ”?
- ì¬ê·€ë³´ë‹¤ ë°˜ë³µë¬¸ì´ ë” ì•ˆì „í•œ ì´ìœ ëŠ”?
- í™•ì¥ ìœ í´ë¦¬ë“œê°€ í•„ìš”í•œ ë¬¸ì œëŠ” ì–´ë–¤ ê²ƒ?
- GCDê°€ 1ì´ë¼ëŠ” ê±´ ì–´ë–¤ ì˜ë¯¸ì¸ê°€?

### âœ… ì •ë¦¬ ìš”ì•½

| í•­ëª©          | ì„¤ëª…                                   |
| ------------- | -------------------------------------- |
| GCD ì •ì˜      | ë‘ ìˆ˜ì˜ ê³µì•½ìˆ˜ ì¤‘ ìµœëŒ€ê°’               |
| ìœ í´ë¦¬ë“œ ê³µì‹ | GCD(A, B) = GCD(B, A % B)              |
| ì‹œê°„ë³µì¡ë„    | O(log A)                               |
| ì‘ìš©          | LCM, ì•½ë¶„, ëª¨ë“ˆëŸ¬ ì—°ì‚°, ì •ìˆ˜ í•´ êµ¬í•˜ê¸° |
| í™•ì¥ ë²„ì „     | ax + by = GCD(a, b) ë§Œì¡±í•˜ëŠ” x, y êµ¬í•¨ |

## ëª¨ë“ˆëŸ¬ ì‚°ìˆ , ê±°ë“­ì œê³±, ì—­ì›

### ğŸ“˜ 1. ëª¨ë“ˆëŸ¬ ì‚°ìˆ  (Modular Arithmetic)

> "ì •ìˆ˜ ì—°ì‚°ì—ì„œ ë‚˜ë¨¸ì§€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•˜ëŠ” ê³„ì‚° ì²´ê³„"

#### âœ¨ ê¸°ë³¸ ì •ì˜

```
a â‰¡ b mod m  â‡”  (a - b)ê°€ mì˜ ë°°ìˆ˜ì´ë‹¤
```

#### ğŸ“Œ ëª¨ë“ˆëŸ¬ ì—°ì‚°ì˜ ì„±ì§ˆ

| ì—°ì‚°     | ì„±ì§ˆ                                          |
| -------- | --------------------------------------------- |
| ë§ì…ˆ     | (a + b) mod m = (a mod m + b mod m) mod m     |
| ëº„ì…ˆ     | (a - b) mod m = (a mod m - b mod m + m) mod m |
| ê³±ì…ˆ     | (a Ã— b) mod m = (a mod m Ã— b mod m) mod m     |
| ë‚˜ëˆ—ì…ˆ â— | **ë¶ˆê°€ëŠ¥í•¨!** â†’ â†’ ë°˜ë“œì‹œ `ëª¨ë“ˆëŸ¬ ì—­ì›` í•„ìš”   |

#### ì˜ˆì‹œ

```
(17 + 23) % 5 = 40 % 5 = 0
(17 * 23) % 5 = (2 * 3) % 5 = 6 % 5 = 1
```

### ğŸ“— 2. ëª¨ë“ˆëŸ¬ ê±°ë“­ì œê³± (Modular Exponentiation)

> `(a^b) % m`ì„ **ë¹ ë¥´ê²Œ** ê³„ì‚°í•˜ëŠ” ë°©ë²•
>  ë°˜ë³µ ì œê³±ë²•(Pow-by-Squaring) ì‚¬ìš©

#### âœ… ë°˜ë³µ ì œê³±ë²• ì½”ë“œ (O(log b))

```
long long modPow(long long a, long long b, long long m) {
    long long res = 1;
    a %= m;
    while (b > 0) {
        if (b & 1) res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
```

#### ì˜ˆì‹œ

```
(3^13) % 7 = ?
â†’ ê³„ì‚° ê³¼ì •:
3^1 = 3
3^2 = 9 % 7 = 2
3^4 = 2^2 = 4
3^8 = 4^2 = 16 % 7 = 2

â†’ ìµœì¢… = (3^8) * (3^4) * (3^1) = 2 * 4 * 3 = 24 % 7 = 3
```

### ğŸ“™ 3. ëª¨ë“ˆëŸ¬ ì—­ì› (Modular Inverse)

> ë‚˜ëˆ—ì…ˆ `a / b mod m`ì„ ê³„ì‚°í•˜ë ¤ë©´
>  `b^-1 mod m`ì„ ë¨¼ì € êµ¬í•´ì•¼ í•¨

#### âœ… ì •ì˜

```
b^-1 â‰¡ x (mod m) such that (b * x) % m == 1
```

#### ğŸ“Œ ì¡°ê±´

- `b`ì™€ `m`ì´ **ì„œë¡œì†Œ(GCD(b, m) == 1)** ì—¬ì•¼ë§Œ ì—­ì›ì´ ì¡´ì¬í•œë‹¤

#### ë°©ë²• 1ï¸âƒ£: **í™•ì¥ ìœ í´ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜**

```
long long extendedGCD(long long a, long long b, long long &x, long long &y) {
    if (b == 0) { x = 1; y = 0; return a; }
    long long x1, y1;
    long long g = extendedGCD(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return g;
}

long long modInverse(long long a, long long m) {
    long long x, y;
    long long g = extendedGCD(a, m, x, y);
    if (g != 1) return -1; // ì—­ì› ì¡´ì¬ ì•ˆ í•¨
    return (x % m + m) % m;
}
```

#### ë°©ë²• 2ï¸âƒ£: **í˜ë¥´ë§ˆì˜ ì†Œì •ë¦¬** (mì´ ì†Œìˆ˜ì¼ ë•Œë§Œ)

> ```
> a^(m-2) â‰¡ a^-1 mod m
> ```

```
long long modInverseFermat(long long a, long long m) {
    return modPow(a, m - 2, m);
}
```

### âœ… ì˜ˆì‹œ

```
// (12 / 5) % 17
long long a = 12, b = 5, m = 17;
long long b_inv = modInverse(b, m);
long long result = a * b_inv % m;  // = 12 * 7 % 17 = 16
```

### ğŸ“š ì‘ìš©

| ì‘ìš© ì‚¬ë¡€                  | ì„¤ëª…                  |
| -------------------------- | --------------------- |
| ì¡°í•© nCr % p               | íŒ©í† ë¦¬ì–¼ ì—­ì› í•„ìš”    |
| ëª¨ë“ˆëŸ¬ ë‚˜ëˆ—ì…ˆ              | a / b â‰¡ a * bâ»Â¹ mod m |
| RSA ë³µí˜¸í™” í‚¤ d ê³„ì‚°       | eâ»Â¹ mod Ï†(n)          |
| ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬ (CRT) | M_i^-1 mod m í•„ìš”     |

### âœ… ìš”ì•½ ì •ë¦¬

| í•­ëª©             | ë‚´ìš©                                           |
| ---------------- | ---------------------------------------------- |
| ëª¨ë“ˆëŸ¬ ì‚°ìˆ       | mod ì—°ì‚° ì„±ì§ˆ í™œìš©                             |
| ê±°ë“­ì œê³±         | `O(log b)` ë°˜ë³µ ì œê³±ë²•                         |
| ì—­ì› ì¡°ê±´        | GCD(a, m) = 1ì¼ ë•Œë§Œ                           |
| ì—­ì› ê³„ì‚° ë°©ë²•   | í™•ì¥ ìœ í´ë¦¬ë“œ, í˜ë¥´ë§ˆ ì†Œì •ë¦¬ (modê°€ ì†Œìˆ˜ì¼ ë•Œ) |
| ë‚˜ëˆ—ì…ˆ ê³„ì‚° ë°©ë²• | `a / b â‰¡ a * bâ»Â¹ mod m`                        |

## ì¡°í•©ë¡ (Combinatorics), ë™ì  í…Œì´ë¸” ê¸°ë°˜

### ğŸ“Œ 1. ì¡°í•©ì˜ ê¸°ë³¸ ì •ì˜

> "nê°œì˜ ì›ì†Œ ì¤‘ì—ì„œ rê°œë¥¼ **ìˆœì„œ ì—†ì´** ê³ ë¥´ëŠ” ê²½ìš°ì˜ ìˆ˜"

```
C(n, r) = n! / (r! * (n - r)!)
```

í•˜ì§€ë§Œ íŒ©í† ë¦¬ì–¼ ê³„ì‚°ì€ ê°’ì´ í¬ê³ , ë‚˜ëˆ—ì…ˆì€ **mod ì—°ì‚°ì—ì„œ ìœ„í—˜í•¨**
 â†’ ê·¸ë˜ì„œ ìš°ë¦¬ëŠ” **ë™ì  í…Œì´ë¸” ë°©ì‹**ìœ¼ë¡œ ì ‘ê·¼í•¨.

### ğŸ§  2. íŒŒìŠ¤ì¹¼ì˜ ì‚¼ê°í˜•(Pascal's Triangle) ì¬ê·€ ê´€ê³„

```
C(n, r) = C(n - 1, r - 1) + C(n - 1, r)
```

- ì˜ë¯¸:
  - `rë²ˆì§¸ í•­ì„ ê³ ë¥´ëŠ” ê²½ìš°` + `ì•ˆ ê³ ë¥´ëŠ” ê²½ìš°`
- ê¸°ì € ì¡°ê±´:
  - `C(n, 0) = C(n, n) = 1`

### ğŸ“¦ 3. DP í…Œì´ë¸” ê¸°ë°˜ êµ¬í˜„

#### âœ… C++ ë²„ì „ (ìµœëŒ€ nê¹Œì§€ ëª¨ë“  ì¡°í•© ê³„ì‚°)

```
const int MAX = 1001;
int comb[MAX][MAX];
const int MOD = 1e9 + 7;

void buildComb() {
    for (int n = 0; n < MAX; ++n) {
        comb[n][0] = comb[n][n] = 1;
        for (int r = 1; r < n; ++r) {
            comb[n][r] = (comb[n-1][r-1] + comb[n-1][r]) % MOD;
        }
    }
}
```

- **ì‹œê°„ë³µì¡ë„**: O(nÂ²)
- **ë©”ëª¨ë¦¬ë³µì¡ë„**: O(nÂ²)
- `comb[n][r]` = C(n, r) % MOD

### ğŸ”§ 4. ë©”ëª¨ë¦¬ ìµœì í™” (1ì°¨ì› DP)

> ê°™ì€ í–‰ë§Œ í•„ìš”í•˜ë¯€ë¡œ **1ì°¨ì› ë°°ì—´**ë¡œë„ ê°€ëŠ¥
>  (ì—­ìˆœìœ¼ë¡œ ê°±ì‹ )

```
int comb[MAX];
comb[0] = 1;
for (int n = 1; n <= N; ++n) {
    for (int r = n; r >= 1; --r) {
        comb[r] = (comb[r] + comb[r - 1]) % MOD;
    }
}
```

### ğŸ”¢ 5. ì¡°í•©ë¡  ê´€ë ¨ ë¬¸ì œ ìœ í˜•

| ìœ í˜•                      | ì ‘ê·¼ ë°©ì‹                         |
| ------------------------- | --------------------------------- |
| ê²½ë¡œ ìˆ˜ (ì˜¤ë¥¸ìª½, ì•„ë˜ë§Œ)  | C(n + m, n)                       |
| ì´í•­ ê³„ìˆ˜                 | DP ë˜ëŠ” í˜ë¥´ë§ˆ ê¸°ë°˜               |
| ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ì§€ ì•Šê²Œ ë°°ì¹˜ | Inclusion-Exclusion               |
| ë¬¸ìì—´ ê°œìˆ˜ ì¡°í•©          | DP with ì¡°í•©                      |
| nê°œì˜ ìˆ«ì í•©ì´ k         | DP[n][k] = DP[n][k - i] + ...     |
| íŒŒí‹°ì…˜, ì •ìˆ˜ ë¶„í•          | p(n, k) = p(n-1, k-1) + p(n-k, k) |

### ğŸ¯ 6. nCr % p ê³„ì‚° (pëŠ” ì†Œìˆ˜)

> DP í…Œì´ë¸” ëŒ€ì‹  **íŒ©í† ë¦¬ì–¼ & ì—­ì›**ì„ ì‚¬ì „ ê³„ì‚°í•´ì„œë„ ê°€ëŠ¥

#### íŒ©í† ë¦¬ì–¼ ì‚¬ì „ ê³„ì‚° + ëª¨ë“ˆëŸ¬ ì—­ì›

```
long long fact[MAX], inv[MAX];

void initFactorials(int N) {
    fact[0] = 1;
    for (int i = 1; i <= N; ++i)
        fact[i] = fact[i - 1] * i % MOD;
    
    inv[N] = modPow(fact[N], MOD - 2, MOD);
    for (int i = N - 1; i >= 0; --i)
        inv[i] = inv[i + 1] * (i + 1) % MOD;
}

long long nCr(int n, int r) {
    if (r < 0 || r > n) return 0;
    return fact[n] * inv[r] % MOD * inv[n - r] % MOD;
}
```

- ì‹œê°„ë³µì¡ë„: O(1) per query after O(N) precomputation
- ë§¤ìš° ë¹ ë¦„, ëŒ€í˜• ë¬¸ì œì—ì„œ ë§ì´ ì‚¬ìš©ë¨

### ğŸ’¡ 7. ì‹¤ì „ ì˜ˆì‹œ

| ë¬¸ì œ ìœ í˜•                    | ì¡°í•© ì ìš© ì˜ˆ              |
| ---------------------------- | ------------------------- |
| ë‘ ì§‘í•©ì˜ êµì§‘í•© ê°œìˆ˜ ê³„ì‚°   | Inclusion-Exclusion       |
| ìƒ‰ì¹ , ë°°ì¹˜, ì•‰ê¸°             | ì¡°í•© or ìˆœì—´              |
| íšŒì „ëŒ€ì¹­ ì œê±°                | ì¡°í•© / ìˆœì—´ - ê³ ì •ì  ì œê±° |
| ì´í•­ ì •ë¦¬, ë‹¤í•­ ê³„ìˆ˜         | nCr * a^r * b^(n - r)     |
| íŠ¹ì • ì¡°ê±´ì— ë”°ë¥¸ êµ¬ë¶„ ë‚˜ëˆ„ê¸° | ì¡°í•© + DP                 |

### ğŸ§  ì¸í„°ë·° ì§ˆë¬¸ ëŒ€ë¹„

- ì¡°í•©ì„ O(1)ì— êµ¬í•˜ëŠ” ë°©ë²•ì€?
- nCr % pê°€ ì™œ ëª¨ë“ˆëŸ¬ ì—­ì›ì„ ì‚¬ìš©í•˜ë‚˜?
- ì¡°í•©ì´ 2ì°¨ì› DPê°€ ê°€ëŠ¥í•œ ì´ìœ ëŠ”?
- nCr = nC(n-r) ì´ ì„±ë¦½í•˜ëŠ” ì´ìœ ëŠ”?

### âœ… ì •ë¦¬ ìš”ì•½

| í•­ëª©        | ì„¤ëª…                                      |
| ----------- | ----------------------------------------- |
| ì •ì˜        | nê°œ ì¤‘ rê°œë¥¼ ê³ ë¥´ëŠ” ê²½ìš°ì˜ ìˆ˜             |
| DP ì¬ê·€ì‹   | C(n, r) = C(n-1, r-1) + C(n-1, r)         |
| êµ¬í˜„ ë°©ì‹   | 2ì°¨ì› í…Œì´ë¸”, 1ì°¨ì› ìµœì í™”, íŒ©í† ë¦¬ì–¼ ë°©ì‹ |
| ëª¨ë“ˆëŸ¬ ì—°ì‚° | % p ê³„ì‚° ì‹œ ì—­ì› í•„ìš”                     |
| ì‹œê°„ë³µì¡ë„  | O(nÂ²) or O(1) (ì‚¬ì „ ê³„ì‚° í›„)              |
| í™œìš© ë¶„ì•¼   | ê²½ë¡œ, ë°°ì¹˜, ë‚˜ëˆ—ì…ˆ, ì•”í˜¸í•™, ìˆ˜í•™ ë“±       |

