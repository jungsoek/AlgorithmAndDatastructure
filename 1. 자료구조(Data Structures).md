# 1. 자료구조(Data Structures)

# 1.1 기본 개념

## 자료구조란 무엇인가?

### 1. 정의

**자료구조(Data Structure)**란 데이터를 **효율적으로 저장하고 관리하며 처리**하기 위한 논리적, 수학적 구조를 말한다. 프로그램의 목적에 따라 데이터를 어떤 방식으로 저장하고 접근할 것인가를 결정하는 것이 핵심이다.
 즉, 자료구조는 데이터에 대한 *조직화된 표현과 접근 방식*이다.

> 📌 **정식 정의:**
>  "자료구조는 데이터를 조직하고 저장하는 방식이며, 다양한 연산(삽입, 삭제, 탐색, 정렬 등)을 효율적으로 수행할 수 있도록 설계된 데이터의 논리적 모델이다."

### 2. 자료구조의 목적

| 목적                  | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| **효율성 증대**       | 주어진 연산(탐색, 삽입, 삭제 등)에 대해 시간/공간 효율을 극대화 |
| **문제 해결 구조화**  | 알고리즘 설계 및 문제 해결을 체계적이고 예측 가능하게 구성   |
| **재사용성과 모듈화** | 잘 설계된 자료구조는 다른 문제에 재활용 가능하며, 코드 유지보수가 쉬움 |

### 3. 자료구조의 분류

자료구조는 **구조의 형태**에 따라 크게 다음과 같이 분류된다:

#### A. 선형 구조 (Linear Data Structures)

데이터가 순차적으로 연결되어 있으며, 각 요소가 이전/다음 요소와 1:1로 연결됨.

| 구조   | 설명                                    |
| ------ | --------------------------------------- |
| 배열   | 연속적인 메모리 블록에 데이터 저장      |
| 리스트 | 연결 노드를 통해 구성됨 (단일, 이중 등) |
| 스택   | 후입선출 (LIFO) 구조                    |
| 큐     | 선입선출 (FIFO) 구조                    |

#### B. 비선형 구조 (Non-Linear Data Structures)

데이터 간 관계가 비선형적이며, 계층적 또는 그물망 구조를 가짐.

| 구조   | 설명                                      |
| ------ | ----------------------------------------- |
| 트리   | 계층적 구조 (루트, 자식 노드 등)          |
| 그래프 | 복잡한 관계를 표현, 방향성 및 가중치 가능 |

#### C. 해시 기반 구조 (Hash-based)

- 해시 테이블
- 집합, 맵 (Set, Map)

### 4. 자료구조 vs 추상 자료형(ADT)

| 구분      | 자료구조                              | 추상 자료형(ADT)                |
| --------- | ------------------------------------- | ------------------------------- |
| 개념      | 물리적 데이터 저장 방식               | 논리적 데이터 모델              |
| 구현 여부 | 메모리 구조와 알고리즘 포함           | 인터페이스만 정의 (구현은 숨김) |
| 예시      | 배열, 연결 리스트, 힙, 해시 테이블 등 | 스택, 큐, 덱, 리스트, 트리 등   |

> 예: 스택이라는 ADT는 배열 또는 연결 리스트를 사용해 구현될 수 있음

### 5. 자료구조 선택의 기준

- **데이터 접근 방식:** 순차/임의 접근이 필요한가?
- **삽입/삭제 빈도:** 빈번한 삽입/삭제가 있는가?
- **검색 우선 순위:** 어떤 데이터를 더 자주 검색하는가?
- **메모리 제약:** 메모리 공간이 제한되어 있는가?

### 6. 자료구조와 알고리즘의 관계

자료구조는 **알고리즘의 효율성**을 결정짓는 핵심 기반이다.
 잘못된 자료구조 선택은 아무리 좋은 알고리즘을 사용해도 성능 저하로 이어진다.

> 예: 힙 자료구조를 사용하면 O(log n)의 시간 복잡도로 우선순위 추출이 가능함 → 다익스트라 알고리즘 등에서 필수

### 7. 실제 예시

| 응용 분야             | 사용되는 자료구조                 |
| --------------------- | --------------------------------- |
| 브라우저 뒤로가기     | 스택                              |
| 운영체제의 작업 큐    | 큐                                |
| 디렉터리 구조 탐색    | 트리                              |
| SNS 친구 추천         | 그래프                            |
| 해시 기반 캐시 시스템 | 해시 테이블 (LRU 알고리즘과 결합) |

### 8. 결론

자료구조는 소프트웨어의 성능, 안정성, 확장성에 직결되는 기반 기술이다.
 **문제 해결의 정교함은 자료구조의 선택과 구현에 달려 있다.**
 따라서 프로그래밍 학습자 및 개발자는 다양한 자료구조를 이해하고, 상황에 따라 올바르게 활용할 수 있어야 한다.

## 추상 자료형(Abstract Data Type, ADT)의 개념

### 1. 정의

**추상 자료형(Abstract Data Type, ADT)**이란 **데이터와 이 데이터를 다루는 연산을 수학적으로 모델링한 개념**이다. 구체적인 구현 방식(메모리 구조나 알고리즘)은 감추고, 오직 **무엇을 할 수 있는가(동작)**에만 초점을 맞춘 자료의 *추상적 정의*라고 할 수 있다.

> 📌 정식 정의:
>  “추상 자료형은 자료의 표현 방식과 자료에 대한 연산을 함께 정의한 수학적 모델로, 데이터의 내부 구현은 숨기고 외부에는 연산만을 노출하는 추상화된 구조이다.”

### 2. 핵심 개념

| 항목         | 설명                                                         |
| ------------ | ------------------------------------------------------------ |
| **추상화**   | 구현 세부를 감추고, 연산(인터페이스)만 정의하여 사용자 관점에서 단순화 |
| **캡슐화**   | 데이터와 관련 연산을 하나의 단위로 묶고, 외부에는 인터페이스만 제공 |
| **모듈성**   | 프로그램을 연산 단위로 나눠 독립적으로 작성 가능             |
| **재사용성** | 다양한 구현으로 재사용 가능 (예: 배열 기반/연결 리스트 기반 스택) |

### 3. ADT의 구조 구성 요소

| 구성 요소           | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| **데이터**          | ADT가 저장하고 처리하는 데이터 요소                          |
| **연산(Operation)** | 데이터를 생성, 삽입, 삭제, 탐색 등 다양한 방식으로 처리하는 동작 정의 |
| **제약 조건**       | 연산 순서나 수행 가능 여부 등 ADT가 지켜야 할 규칙           |

예시: 스택(Stack) ADT

- **데이터**: 요소들의 모음
- **연산**: `push()`, `pop()`, `top()`
- **제약 조건**: 후입선출(LIFO)

### 4. ADT와 자료구조의 차이점

| 구분           | 추상 자료형 (ADT)             | 자료구조 (Data Structure)                      |
| -------------- | ----------------------------- | ---------------------------------------------- |
| 정의 수준      | 논리적 (인터페이스 중심)      | 물리적 (구현 중심)                             |
| 접근 방식      | "무엇을 할 수 있는가?"를 정의 | "어떻게 구현하는가?"에 집중                    |
| 구현 포함 여부 | 구현 세부는 포함하지 않음     | 구현 포함 (메모리 구조, 포인터 등)             |
| 예시           | 스택, 큐, 트리, 맵            | 배열, 연결 리스트, 해시 테이블, 이진 탐색 트리 |

> 예: 스택(ADT)은 추상적인 개념이고, 이를 배열로 구현할 수도 있고 연결 리스트로도 구현할 수 있음.

### 5. 주요 ADT 예시

| ADT 이름          | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| **리스트(List)**  | 선형 순서를 갖는 원소의 모음, 삽입/삭제/검색 연산 제공       |
| **스택(Stack)**   | 후입선출(LIFO) 방식의 선형 구조                              |
| **큐(Queue)**     | 선입선출(FIFO) 방식의 선형 구조                              |
| **덱(Deque)**     | 양쪽에서 삽입과 삭제가 가능한 큐                             |
| **트리(Tree)**    | 계층적 구조, 부모-자식 관계를 갖는 비선형 구조               |
| **그래프(Graph)** | 노드(정점)와 노드 간의 간선(연결관계)로 구성된 복잡한 관계형 구조 |
| **맵(Map)**       | 키-값 쌍의 연관 배열, 빠른 검색 연산이 특징                  |
| **집합(Set)**     | 중복 없는 데이터의 집합, 합집합/교집합/차집합 등의 집합 연산 지원 |

### 6. 추상 자료형과 객체지향

추상 자료형의 개념은 **객체지향 프로그래밍(OOP)**의 핵심 개념인 클래스 및 인터페이스와 매우 유사하다.

| ADT 개념    | OOP 대응 개념       |
| ----------- | ------------------- |
| 연산 정의   | 메서드(Method) 정의 |
| 데이터 은닉 | private 멤버 변수   |
| 연산만 노출 | public 인터페이스   |

> 클래스는 ADT를 코드 수준에서 표현하는 대표적인 방법 중 하나다.

### 7. ADT를 사용하는 이유

- 구현의 변경 없이도 인터페이스는 유지됨 → **유지보수 용이**
- 데이터에 대한 **보안성과 무결성** 보장
- 복잡한 구조도 간결하게 표현 → **추상화된 사고 가능**
- 다양한 구현체(배열 기반/포인터 기반 등)와 **전략적 선택 가능**

### 8. 결론

추상 자료형은 자료구조를 **논리적 관점**에서 정의하는 이론적 기반이다.
 자료구조가 “어떻게 구현할 것인가”라면, ADT는 “무엇을 할 수 있는가”에 집중한다.
 **모든 자료구조 구현의 출발점은 ADT 정의로부터 시작되며**, 이로써 모듈화된 설계, 추상화된 사고, 유지보수성이 우수한 소프트웨어 개발이 가능해진다.

## 자료구조의 성능 분석 (공간 복잡도, 시간 복잡도)

### 1. 개요

자료구조의 목적은 단순히 데이터를 저장하는 데 있지 않다. **정해진 시간 안에 데이터를 효율적으로 탐색, 삽입, 삭제**하는 것이 핵심이다. 이를 판단하는 기준이 바로 **성능 분석**이다.

성능 분석은 두 가지 측면에서 이루어진다:

- **시간 복잡도(Time Complexity)**
   → 알고리즘 또는 자료구조의 연산이 실행되는 데 걸리는 **연산 횟수의 증가율**
- **공간 복잡도(Space Complexity)**
   → 알고리즘 또는 자료구조가 사용하는 **메모리의 증가율**

이 둘은 종종 **트레이드오프** 관계를 가지므로 상황에 맞게 균형 있게 고려해야 한다.

### 2. 시간 복잡도(Time Complexity)

#### 2.1 정의

어떤 연산을 수행할 때, 입력 크기 $n$이 증가함에 따라 **필요한 기본 연산의 수**를 수학적으로 표현한 것.

#### 2.2 표기법

| 표기법            | 이름               | 의미                                             |
| ----------------- | ------------------ | ------------------------------------------------ |
| $O(1)$            | 상수 시간          | 입력 크기에 관계없이 일정한 시간 소요            |
| $O(\log n)$       | 로그 시간          | 입력이 2배로 늘어날 때 연산 횟수는 1만큼 증가    |
| $O(n)$            | 선형 시간          | 입력 크기에 비례                                 |
| $O(n \log n)$     | 로그 선형          | 고급 정렬(병합 정렬 등)에서 등장                 |
| $O(n^2)$          | 이차 시간          | 중첩 루프, 행렬 곱셈 등에서 발생                 |
| $O(2^n)$, $O(n!)$ | 지수/팩토리얼 시간 | 매우 비효율적; 브루트포스 백트래킹, 순열 탐색 등 |

#### 2.3 예시

| 연산 종류     | 배열               | 연결 리스트        | 스택/큐 | 해시 테이블 | 이진 탐색 트리 (평균) |
| ------------- | ------------------ | ------------------ | ------- | ----------- | --------------------- |
| 검색 (Search) | $O(1)$ or $O(n)$   | $O(n)$             | $O(n)$  | $O(1)$      | $O(\log n)$           |
| 삽입 (Insert) | $O(n)$ (중간 삽입) | $O(1)$ (앞쪽 기준) | $O(1)$  | $O(1)$      | $O(\log n)$           |
| 삭제 (Delete) | $O(n)$             | $O(1)$ or $O(n)$   | $O(1)$  | $O(1)$      | $O(\log n)$           |

### 3. 공간 복잡도(Space Complexity)

#### 3.1 정의

입력 크기 $n$에 따라 **필요한 메모리 공간의 양**을 수학적으로 표현한 것. 자료구조의 추가 메모리 사용량을 포함하여 계산한다.

#### 3.2 구성 요소

- 입력에 필요한 공간
- 변수, 배열, 오브젝트 등 프로그램 실행 중 생성되는 임시 공간
- 재귀 호출에 사용되는 스택 공간

#### 3.3 예시

| 자료구조    | 공간 복잡도                              |
| ----------- | ---------------------------------------- |
| 배열        | $O(n)$                                   |
| 연결 리스트 | $O(n)$ (노드 + 포인터 공간)              |
| 해시 테이블 | $O(n)$ (버킷 수 + 충돌 처리용 공간 포함) |
| 이진 트리   | $O(n)$ (노드 개수)                       |
| 재귀 DFS    | $O(h)$, $h$: 트리 깊이                   |

### 4. 최악 / 평균 / 최선의 시간 복잡도

| 경우        | 설명                                                       |
| ----------- | ---------------------------------------------------------- |
| **최악(O)** | 최악의 입력에 대한 수행 시간. 성능 보장을 위해 가장 중요.  |
| **평균(Θ)** | 모든 입력의 평균적인 수행 시간. 통계적으로 분석할 때 사용. |
| **최선(Ω)** | 가장 이상적인 경우. 분석 가치가 낮을 수 있음.              |

> 📌 예: 해시 테이블의 탐색 시간
>
> - 최선: $O(1)$
> - 최악: $O(n)$ (모든 해시가 충돌할 경우)

### 5. 시간 vs 공간: Trade-off

| 전략                         | 설명                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 공간을 줄이고 시간 손해      | 예: 연속 정렬 대신 거품 정렬 사용 $→ O(1) 공간, O(n^2) 시간$ |
| 시간을 줄이고 공간 소모 증가 | 예: 해시 테이블 사용 $→ 빠른 탐색, 높은 메모리 사용$         |
| 균형 전략                    | 예: AVL 트리, Red-Black 트리 $→ 로그 시간, 균형된 공간$      |

### 6. 성능 분석 실전 예시

```
// 배열에서 특정 값 찾기 (선형 탐색)
int find(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) return i;
    }
    return -1;
}
```

- **시간 복잡도**: $O(n)$ — 최악의 경우 끝까지 탐색
- **공간 복잡도**: $O(1)$ — 추가 메모리 사용 없음

### 7. 결론

성능 분석은 단순한 이론이 아닌 **알고리즘 선택과 자료구조 구현의 핵심 기준**이다.
 실제 문제 해결 시, 입력 크기, 수행 시간 제약, 메모리 제약을 고려하여 시간 복잡도와 공간 복잡도의 균형을 맞추는 것이 중요하다.

## 빅오(Big-O), 빅세타(Θ), 빅오메가(Ω) 표기법

### 1. 개요

프로그램에서 입력 크기 $n$이 커질 때 **연산 수행 횟수나 자원 소모(시간, 공간)의 변화율**을 수학적으로 나타내는 표기 체계를 **점근적 표기법(Asymptotic Notation)**이라 한다.
 이 표기법은 알고리즘의 "성능 상한/하한/정확도"를 표현하며, 알고리즘 분석의 기본이 된다.

### 2. 표기법 종류 요약

| 기호           | 이름     | 의미                                 |
| -------------- | -------- | ------------------------------------ |
| $O(f(n))$      | 빅오     | **최악의 경우의 상한 (Upper Bound)** |
| $\Theta(f(n))$ | 빅세타   | **정확한 성장률 (Tight Bound)**      |
| $\Omega(f(n))$ | 빅오메가 | **최선의 경우의 하한 (Lower Bound)** |

### 3. 빅오 표기법 $O(f(n))$ — **상한선**

#### 3.1 정의

> 어떤 함수 $T(n)$이 존재할 때, **일정한 계수 $c$**와 **크기 $n_0$**가 존재하여
>  $T(n) \leq c \cdot f(n)$ for all $n \geq n_0$이면
>
> $T(n) = O(f(n))$

#### 3.2 의미

- 알고리즘의 **최악의 실행 시간**을 보장
- 성능을 보수적으로 평가할 때 사용
- 성능 상한: “이보다 느리진 않다”

#### 3.3 예시

```
// 배열 전체 탐색 (선형 탐색)
for (int i = 0; i < n; i++) {
    if (arr[i] == target) return i;
}
```

- 최악의 경우 모든 원소 탐색 → $O(n)$

### 4. 빅세타 표기법 $\Theta(f(n))$ — **정확한 경계**

#### 4.1 정의

> $T(n)$이 상한과 하한 모두에서 $f(n)$에 비례하면
>  즉, 일정한 상수 $c_1, c_2, n_0$가 존재하여
>
> $c_1 \cdot f(n) \leq T(n) \leq c_2 \cdot f(n)$ for all $n \geq n_0$
>
> 이면 $T(n) = \Theta(f(n))$

#### 4.2 의미

- **정확한 성장률**을 나타냄
- 알고리즘의 평균 성능이나 일반적인 경우 분석에 사용

#### 4.3 예시

```
// 일정한 for 루프 반복
for (int i = 0; i < n; i++) {
    sum += i;
}
```

- 항상 정확히 $n$회 반복 → $\Theta(n)$

### 5. 빅오메가 표기법 $\Omega(f(n))$ — **하한선**

#### 5.1 정의

> 일정한 상수 $c, n_0$가 존재하여
>  $T(n) \geq c \cdot f(n)$ for all $n \geq n_0$이면
>
> $T(n) = \Omega(f(n))$

#### 5.2 의미

- **최선의 경우 시간 복잡도**
- “적어도 이 정도는 걸린다”는 의미

#### 5.3 예시

```
// 선형 탐색 시, 첫 원소가 목표일 경우
if (arr[0] == target) return 0;
```

- 한 번에 찾으면 $\Omega(1)$

### 6. 관계 요약 도표

| 표기           | 의미         | 표현 방식                      |
| -------------- | ------------ | ------------------------------ |
| $O(f(n))$      | 상한선       | “**최대** 이만큼 걸릴 수 있다” |
| $\Omega(f(n))$ | 하한선       | “**최소** 이만큼은 걸린다”     |
| $\Theta(f(n))$ | 상/하한 일치 | “정확히 이만큼 걸린다”         |

### 7. 시각적 표현 (그래프 형태)

```
T(n)
│        O(f(n))
│       /
│      /
│     /
│----/-----> f(n)
│   /
│  /
│ /  Ω(f(n))
|/
```

- $O(f(n))$: 위로 덮어 씌움
- $\Omega(f(n))$: 아래에서 지지
- $\Theta(f(n))$: 위아래 둘 다 맞닿음 → 동일한 성장률

### 8. 적용 예시

| 알고리즘            | 최선 ($\Omega$)    | 평균 ($\Theta$)    | 최악 ($O$)  |
| ------------------- | ------------------ | ------------------ | ----------- |
| 선형 탐색           | $\Omega(1)$        | $\Theta(n)$        | $O(n)$      |
| 이진 탐색           | $\Omega(1)$        | $\Theta(\log n)$   | $O(\log n)$ |
| 퀵 정렬 (QuickSort) | $\Omega(n \log n)$ | $\Theta(n \log n)$ | $O(n^2)$    |

### 9. 결론

- 알고리즘의 효율성을 표현할 때 단순히 `for` 반복문의 수만 보는 것은 한계가 있다.
- 점근적 표기법은 알고리즘이 **입력 크기 증가에 따라 얼마나 빨리 느려지거나 빨라지는지를 수학적으로 모델링**한다.
- 세 표기법은 상황에 따라 모두 중요하다.
  - **빅오:** 안전한 상한 예측
  - **빅세타:** 정확한 성장률 파악
  - **빅오메가:** 낙관적 조건 분석

# 1.2 선형 자료구조 (Linear Data Structures)

## 배열(Array)

### 📌 개념 정의

배열(Array)은 **같은 자료형의 데이터를 일정한 순서로 나열해 저장하는 자료구조**다. 각 원소는 **연속된 메모리 공간**에 저장되며, **인덱스(index)**를 통해 빠르게 접근할 수 있다.

- 배열의 크기는 **고정형(fixed size)**이다. (정적 배열 기준)
- 메모리 상에서 **한 덩어리로 연속된 블록**을 차지한다.
- 원소에 접근할 때, **인덱스를 통해 O(1)의 시간복잡도**로 즉시 접근이 가능하다.

### 🧠 메모리 구조 이해

예시: `int arr[5] = {10, 20, 30, 40, 50};`

```
주소   값
1000 → 10   ← arr[0]
1004 → 20   ← arr[1]
1008 → 30   ← arr[2]
1012 → 40   ← arr[3]
1016 → 50   ← arr[4]
```

- 정수형(int)이 4바이트일 경우, 인덱스 * 4 만큼 주소가 이동
- 배열 이름 `arr`은 `arr[0]`의 주소를 가리키는 **포인터** 역할을 한다.

### 📊 배열의 연산 정리

| 연산 종류   | 설명                                               | 시간 복잡도      |
| ----------- | -------------------------------------------------- | ---------------- |
| 접근 Access | `arr[i]`와 같이 인덱스로 직접 접근                 | O(1)             |
| 삽입 Insert | 맨 뒤에 삽입 (공간 여유 시), 중간 삽입은 밀기 필요 | O(1) ~ O(n)      |
| 삭제 Delete | 중간 요소 삭제 시, 뒷 요소를 앞으로 당겨야 함      | O(n)             |
| 탐색 Search | 선형 탐색(순차 탐색) 또는 이진 탐색(정렬된 경우)   | O(n) or O(log n) |

### 🧮 고정 크기 배열 vs 동적 배열

| 항목        | 고정 크기 배열 (Static Array)      | 동적 배열 (Dynamic Array)                 |
| ----------- | ---------------------------------- | ----------------------------------------- |
| 메모리 할당 | 컴파일 타임에 고정 (`int arr[10]`) | 런타임에 동적 (`malloc`, `new`, `vector`) |
| 크기 변경   | 불가능                             | 가능 (재할당 필요)                        |
| 메모리 위치 | 연속                               | 연속 또는 부분 재할당                     |
| 예시 언어   | C 배열, Java 배열                  | C++ vector, Python list, Java ArrayList   |

### 🔧 C언어 배열 예시

```
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};

    printf("arr[2] = %d\n", arr[2]);  // 출력: 3

    arr[2] = 10; // 값 변경
    printf("arr[2] = %d\n", arr[2]);  // 출력: 10

    return 0;
}
```

### 🔧 C++ 동적 배열 (vector)

```
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v;

    v.push_back(1);
    v.push_back(2);
    v.push_back(3);

    cout << v[1] << endl;  // 출력: 2

    return 0;
}
```

### ⚠️ 배열의 한계

- 크기 변경이 불가능 (정적 배열의 경우)
- 삽입, 삭제가 느림 (특히 중간 위치에서)
- 메모리가 연속적이어야 하므로 **큰 배열은 할당 실패 가능성 존재**
- 요소의 자료형이 같아야 함 (유연성 부족)

### 💡 배열 활용 예시

| 분야              | 활용 예                             |
| ----------------- | ----------------------------------- |
| 게임 개발         | 맵 좌표 저장, 상태 배열             |
| 머신러닝          | 텐서 연산 전처리                    |
| 알고리즘          | 정렬, 탐색, 슬라이딩 윈도우 문제 등 |
| 시스템 프로그래밍 | 버퍼, 캐시, 테이블 구현             |

### 🔎 심화 포인트: 배열과 포인터 (C 언어)

```
int arr[3] = {10, 20, 30};
int* p = arr;

printf("%d\n", *(p + 1));  // 20
```

- `arr[i]`는 사실상 `*(arr + i)`와 동일
- 배열 이름은 곧 **시작 주소를 담은 상수 포인터**

### 🧠 인터뷰 대비: 자주 나오는 배열 문제

| 문제 유형       | 예시                           |
| --------------- | ------------------------------ |
| 슬라이딩 윈도우 | 최대/최소 합 구하기            |
| 투 포인터       | 정렬된 배열의 두 수의 합       |
| 중복 제거       | 중복 없이 배열 정렬            |
| 회전 배열 탐색  | Rotated Sorted Array 탐색 문제 |
| 이진 탐색 응용  | Lower Bound, Upper Bound       |

## 연결 리스트(Linked List)

### 📌 개념 정의

연결 리스트는 **데이터와 다음 노드의 주소를 함께 저장하는 노드(Node)**들이 **체인처럼 연결된 동적 자료구조**다.

- 배열과 달리 **메모리 공간이 연속적이지 않아도 됨**
- **삽입과 삭제가 빠름** (특히 리스트 중간이나 앞부분에서)
- 각 노드는 보통 다음과 같은 구조를 가짐:

```
+---------+----------+
|  data   |  next    | → 다음 노드 주소
+---------+----------+
```

### 🧠 왜 쓰는가?

| 배열           | 연결 리스트    |
| -------------- | -------------- |
| 크기 고정      | 동적 크기      |
| 삽입/삭제 느림 | 빠름           |
| 접근 빠름 O(1) | 접근 느림 O(n) |

### 📂 연결 리스트의 종류

| 종류             | 특징                                         |
| ---------------- | -------------------------------------------- |
| 단일 연결 리스트 | 노드가 한 방향(→)으로만 연결됨               |
| 이중 연결 리스트 | 양방향(↔)으로 연결되어 이전 노드도 참조 가능 |
| 원형 연결 리스트 | 마지막 노드가 첫 노드를 가리킴 (순환 구조)   |

### 1️⃣ 단일 연결 리스트 (Singly Linked List)

#### 🔧 구조 정의 (C 언어)

```
typedef struct Node {
    int data;
    struct Node* next;
} Node;
```

#### 주요 연산

| 연산             | 설명                               | 시간 복잡도 |
| ---------------- | ---------------------------------- | ----------- |
| 삽입 (앞)        | head 앞에 새 노드 추가             | O(1)        |
| 삽입 (중간/끝)   | 원하는 위치까지 탐색 후 삽입       | O(n)        |
| 삭제             | 이전 노드를 알아야 삭제 가능       | O(n)        |
| 탐색             | 특정 값을 찾을 때 끝까지 순회 필요 | O(n)        |
| 접근 (임의 위치) | 인덱스로 직접 접근 불가            | O(n)        |

#### 삽입 예시

```
void insert_front(Node** head, int value) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    new_node->data = value;
    new_node->next = *head;
    *head = new_node;
}
```

### 2️⃣ 이중 연결 리스트 (Doubly Linked List)

#### 🔧 구조 정의

```
typedef struct DNode {
    int data;
    struct DNode* prev;
    struct DNode* next;
} DNode;
```

#### 특징

- 양방향 순회 가능 (`next`, `prev`)
- 삭제 연산이 단일 연결 리스트보다 편리
- 메모리 사용량이 더 많고 관리가 복잡

#### 삽입 예시

```
void insert_after(DNode* node, int value) {
    DNode* new_node = (DNode*)malloc(sizeof(DNode));
    new_node->data = value;
    new_node->next = node->next;
    new_node->prev = node;

    if (node->next != NULL)
        node->next->prev = new_node;

    node->next = new_node;
}
```

### 3️⃣ 원형 연결 리스트 (Circular Linked List)

#### 특징

- 마지막 노드가 다시 **첫 노드를 가리킴**
- 리스트 끝에서 처음으로 쉽게 순환 가능
- 게임, 스케줄러, 큐 등에서 유용함

#### 구조 예시

```
Node* head = NULL;

Node* create_node(int val) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = val;
    node->next = node;  // 자기 자신을 가리킴
    return node;
}
```

### 📊 성능 비교표

| 연산         | 단일 리스트 | 이중 리스트 | 원형 리스트 |
| ------------ | ----------- | ----------- | ----------- |
| 앞 삽입      | O(1)        | O(1)        | O(1)        |
| 중간/끝 삽입 | O(n)        | O(n)        | O(n)        |
| 삭제         | O(n)        | O(n)        | O(n)        |
| 양방향 탐색  | 불가능      | 가능        | 가능        |
| 원형 순회    | 구현 복잡   | 구현 복잡   | 자연스러움  |

### 🧠 연결 리스트의 응용

| 분야        | 활용 예                                 |
| ----------- | --------------------------------------- |
| 운영체제    | 프로세스 스케줄링, 페이지 교체 알고리즘 |
| 컴파일러    | 토큰, AST 생성 등                       |
| 웹 브라우저 | 방문 기록 ←→ 앞/뒤로 이동               |
| 자료구조    | 스택, 큐, 해시체인의 충돌 처리          |

### 💡 인터뷰/코딩 테스트 단골 문제

| 문제 유형          | 예시                                    |
| ------------------ | --------------------------------------- |
| 중간 노드 삭제     | "주어진 노드만 가지고 삭제하기"         |
| 역순 리스트 만들기 | "Reverse a Linked List"                 |
| 사이클 탐지        | Floyd's Cycle Detection (토끼와 거북이) |
| 교차점 찾기        | 두 리스트가 만나는 지점 탐색            |
| K번째 노드 찾기    | Fast & Slow 포인터 기법                 |

### ☠️ 주의 사항 (C 언어 기준)

- `malloc`/`free` 사용 시 **메모리 누수 주의**
- 포인터 조작 실수로 인해 **세그먼트 오류 (segfault)** 발생 가능
- 삭제 시 **이전 노드 추적 필요** → `prev` 없으면 어렵다

### 📘 언어별 기본 구현 클래스

| 언어   | 내장 연결 리스트                    |
| ------ | ----------------------------------- |
| C      | 없음 (직접 구현)                    |
| C++    | `std::list`, `std::forward_list`    |
| Java   | `LinkedList<E>` (이중 연결 리스트)  |
| Python | `collections.deque`, 직접 구현 필요 |
| Go     | `container/list` 패키지             |

## 스택(Stack)

### 📌 개념 정의

**스택(Stack)**은 **후입선출(Last-In, First-Out, LIFO)** 방식으로 작동하는 **선형 자료구조**다.
 즉, 나중에 들어간 데이터가 먼저 나오는 구조.

```
Top → [ D ] ← 가장 나중에 들어온 요소
       [ C ]
       [ B ]
Bottom → [ A ] ← 가장 먼저 들어간 요소
```

### 🧠 용도 및 특징

| 항목           | 설명                                           |
| -------------- | ---------------------------------------------- |
| 삽입/삭제 위치 | 항상 **Top(맨 위)**에서만 수행                 |
| 메모리 구조    | 배열 기반 or 연결 리스트 기반                  |
| 사용 예시      | 재귀 호출, 괄호 검사, DFS, 언어 파서, 백트래킹 |

### 📊 기본 연산

| 연산 이름             | 설명                          | 시간 복잡도 |
| --------------------- | ----------------------------- | ----------- |
| `push(x)`             | 스택에 x를 추가               | O(1)        |
| `pop()`               | 스택의 Top 요소 제거 및 반환  | O(1)        |
| `peek()` 또는 `top()` | Top 요소를 제거하지 않고 확인 | O(1)        |
| `isEmpty()`           | 스택이 비었는지 확인          | O(1)        |
| `size()`              | 스택에 있는 원소 개수 반환    | O(1)        |

### 🔧 배열 기반 구현 (C)

```
#define MAX 100
int stack[MAX];
int top = -1;

void push(int x) {
    if (top >= MAX - 1) return;
    stack[++top] = x;
}

int pop() {
    if (top < 0) return -1;
    return stack[top--];
}

int peek() {
    return stack[top];
}

```

### 🔧 연결 리스트 기반 구현 (C)

```
typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* top = NULL;

void push(int x) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = x;
    node->next = top;
    top = node;
}

int pop() {
    if (top == NULL) return -1;
    int val = top->data;
    Node* temp = top;
    top = top->next;
    free(temp);
    return val;
}
```

### 📦 언어별 스택 클래스

| 언어       | 내장 스택 자료구조               |
| ---------- | -------------------------------- |
| C          | 없음 (직접 구현)                 |
| C++        | `std::stack<T>` (`deque` 기반)   |
| Java       | `Stack<T>`, `Deque<T>` 사용 권장 |
| Python     | `list`, `collections.deque`      |
| JavaScript | `Array.push`, `Array.pop`        |

### 🧭 스택의 대표적인 응용 사례

| 분야                | 사용 사례                          |
| ------------------- | ---------------------------------- |
| 컴파일러/인터프리터 | 함수 호출 스택 (Call Stack)        |
| 알고리즘            | DFS, 백트래킹                      |
| 수식 계산           | 중위 → 후위 변환, 후위 표기식 계산 |
| 괄호 검사           | 중첩 구조 유효성 판별              |
| 웹 브라우저         | 뒤로가기 / 앞으로 가기 히스토리    |
| 재귀 제거           | 명시적 스택으로 재귀 함수 대체     |

### 💡 실전 코딩 테스트/인터뷰 문제

| 문제 유형          | 예시                                   |
| ------------------ | -------------------------------------- |
| 괄호 유효성 검사   | `isValid("()[]{}")`                    |
| 후위 표기식 계산   | `evalRPN(["2", "1", "+", "3", "*"])`   |
| 최소값 스택        | `MinStack`, `getMin()`을 O(1)로        |
| 스택 2개로 큐 구현 | `push`, `pop`, `peek`, `empty`         |
| 스택 순열 판별     | 스택을 사용해서 가능한 출력 시퀀스인지 |

### 🔂 심화 포인트: 재귀와 스택

재귀 함수는 **컴파일러가 내부적으로 스택을 이용해서 구현**한다.
 함수가 호출될 때마다 **현재 상태가 스택에 저장**되고, 함수가 끝나면 **스택에서 꺼내 복귀**한다.

예시:

```
void recurse(int n) {
    if (n == 0) return;
    recurse(n - 1);
    printf("%d ", n);  // 스택에 쌓였다가 역순으로 출력됨
}
```

### 📌 스택 vs 큐

| 항목      | 스택(Stack) | 큐(Queue)           |
| --------- | ----------- | ------------------- |
| 구조      | LIFO        | FIFO                |
| 삽입 위치 | Top         | Rear                |
| 삭제 위치 | Top         | Front               |
| 사용 예시 | 재귀, DFS   | BFS, 스케줄링, 버퍼 |

### ☠️ 스택 오버플로우

- 배열 기반 스택에서 `top >= capacity` 상태로 `push()` 시 발생
- 재귀 함수가 너무 깊을 때 `Stack Overflow` 에러 발생 (Call Stack 한계 초과)

## 큐(Queue)

### 📌 개념 정의

**큐(Queue)**는 **선입선출(First-In, First-Out, FIFO)** 원칙을 따르는 선형 자료구조다.

```
Front → [ A ][ B ][ C ][ D ] ← Rear
```

* 먼저 들어온 A가 먼저 나간다.
* 스택과 달리 **입구(Rear)와 출구(Front)**가 나뉘어 있음.

### 🧠 왜 중요한가?

| 특징               | 설명                                   |
| ------------------ | -------------------------------------- |
| 순서 유지          | 들어온 순서를 유지하며 처리            |
| 삽입/삭제 효율적   | O(1) 시간에 삽입과 삭제                |
| 응용 분야가 다양함 | CPU 스케줄링, 캐시, 네트워크 버퍼, BFS |

### 📊 큐의 기본 연산

| 연산         | 설명                             | 시간복잡도 |
| ------------ | -------------------------------- | ---------- |
| `enqueue(x)` | Rear에 요소 x를 추가             | O(1)       |
| `dequeue()`  | Front의 요소를 제거하고 반환     | O(1)       |
| `peek()`     | 가장 앞의 요소를 반환하되 제거 X | O(1)       |
| `isEmpty()`  | 큐가 비었는지 확인               | O(1)       |
| `size()`     | 큐에 들어 있는 원소의 개수 반환  | O(1)       |

### 🔧 배열 기반 큐 구현 (C 언어)

```
#define MAX 100
int queue[MAX];
int front = 0, rear = 0;

void enqueue(int x) {
    if (rear >= MAX) return;
    queue[rear++] = x;
}

int dequeue() {
    if (front == rear) return -1;
    return queue[front++];
}
```

> ❗ 단점: 삭제된 앞 부분이 비어 있어도 재사용 불가 (메모리 낭비)

### 🔁 원형 큐 (Circular Queue)

#### ✅ 해결책

- **`front`와 `rear`를 순환시켜** 배열 재사용 가능
- **모듈로 연산**을 통해 인덱스 조절

#### 📐 예시 코드

```
#define MAX 100
int queue[MAX];
int front = 0, rear = 0;

int isFull() {
    return (rear + 1) % MAX == front;
}

int isEmpty() {
    return front == rear;
}

void enqueue(int x) {
    if (isFull()) return;
    queue[rear] = x;
    rear = (rear + 1) % MAX;
}

int dequeue() {
    if (isEmpty()) return -1;
    int val = queue[front];
    front = (front + 1) % MAX;
    return val;
}
```

### 🔀 덱(Deque) (Double-Ended Queue)

| 연산         | 설명          |
| ------------ | ------------- |
| `push_front` | 앞쪽에 삽입   |
| `push_back`  | 뒤쪽에 삽입   |
| `pop_front`  | 앞쪽에서 삭제 |
| `pop_back`   | 뒤쪽에서 삭제 |

#### 언어별 지원

| 언어   | 덱 클래스           |
| ------ | ------------------- |
| C++    | `std::deque`        |
| Python | `collections.deque` |
| Java   | `Deque<T>`          |

### 💎 우선순위 큐 (Priority Queue)

- 일반 큐는 들어온 순서대로 처리하지만, 우선순위 큐는 **우선순위가 높은 요소부터 꺼냄**
- **힙(Heap)** 구조로 구현 (최소/최대 힙)

#### 예시 (C++)

```
priority_queue<int> maxPQ;                     // 최대 힙
priority_queue<int, vector<int>, greater<int>> minPQ;  // 최소 힙
```

### ⚙️ 언어별 큐 클래스

| 언어   | 큐 자료구조                                     |
| ------ | ----------------------------------------------- |
| C      | 직접 구현 필요                                  |
| C++    | `std::queue`, `std::deque`, `priority_queue`    |
| Java   | `Queue<T>`, `LinkedList<T>`, `PriorityQueue<T>` |
| Python | `collections.deque`, `queue.Queue`, `heapq`     |
| Go     | slice + 구현 or container/list                  |

### 🧭 큐 활용 사례

| 분야            | 설명                         |
| --------------- | ---------------------------- |
| 운영체제        | 작업 스케줄링, 인터럽트 처리 |
| 네트워크        | 패킷 큐, 버퍼                |
| 그래프 알고리즘 | BFS 탐색 (너비 우선)         |
| 캐시 구조       | FIFO 캐시, LRU               |
| 실시간 처리     | 생산자-소비자 문제           |

### 🧠 실전 문제 / 인터뷰 대비

| 문제 유형            | 예시                   |
| -------------------- | ---------------------- |
| BFS 탐색             | 최단 거리, 미로 탐색   |
| 순환 큐 구현         | 고정 배열로 Queue 구현 |
| 캐시 알고리즘        | LRU Cache              |
| 다중 큐              | Producer-Consumer 문제 |
| 우선순위 처리 시스템 | 응급실, CPU 예약 등    |

### 🧮 큐 vs 스택 비교 요약

| 항목 | 큐 (Queue)    | 스택 (Stack)         |
| ---- | ------------- | -------------------- |
| 구조 | FIFO          | LIFO                 |
| 삽입 | Rear          | Top                  |
| 삭제 | Front         | Top                  |
| 응용 | BFS, 스케줄링 | DFS, 재귀, 수식 계산 |

### ❗ 주의 사항

- 배열 기반 큐는 **초기화 후에도 공간 재사용이 안 되면** 성능 저하 (→ 원형 큐로 해결)
- 연결 리스트 큐는 포인터 오류 및 메모리 누수에 주의
- 다중 큐/동기화 큐는 동시성 문제 고려 필요

## 문자열(String)

### 📌 개념 정의

문자열은 **문자(character)의 연속된 시퀀스**로, 대부분의 프로그래밍 언어에서 **문자열 자료형(String type)**으로 다뤄진다.
 기본적으로는 문자 배열이지만, **불변성, 메모리 관리, 문자 인코딩**에 따라 구현은 다양하다.

### 🔎 문자열의 본질: 문자 배열

- C: `char[]` + null 문자 `\0`로 끝을 표시
- C++: `std::string`은 내부적으로 `char*`와 유사
- Java: `String`은 불변, 내부는 `char[]`
- Python: `str`은 유니코드 문자 배열 (불변)

### 🧠 문자열의 주요 특징

| 항목        | 설명                                     |
| ----------- | ---------------------------------------- |
| 인덱스 접근 | `s[i]` 형태로 특정 문자 접근 (O(1))      |
| 불변성      | Java, Python 등은 문자열이 **immutable** |
| 메모리 관리 | 새로운 문자열 할당 시 복사 발생 가능     |
| 문자 인코딩 | ASCII, UTF-8, UTF-16 등 지원 다양        |

### 📊 기본 연산 정리

| 연산          | 설명                       | 시간복잡도           |
| ------------- | -------------------------- | -------------------- |
| 길이 계산     | `len(s)`                   | O(1) (파이썬은 캐싱) |
| 연결 (concat) | `s1 + s2`                  | O(n)                 |
| 부분 문자열   | `s[start:end]`             | O(k)                 |
| 비교          | `s1 == s2`                 | O(n)                 |
| 검색          | `s.find("abc")`            | O(n) or O(nm)        |
| 변경          | 불변 언어는 복사 후 재할당 | O(n)                 |

### 📐 문자열 구현 방식: 불변 vs 가변

| 언어   | 문자열 특성 | 설명                                         |
| ------ | ----------- | -------------------------------------------- |
| C      | 가변        | `char[]`, 포인터 연산, `strcpy`, `strcat` 등 |
| C++    | 가변        | `std::string` (내부 버퍼 조절 가능)          |
| Java   | 불변        | `String`은 변경 불가 → `StringBuilder` 사용  |
| Python | 불변        | `str`은 immutable → 리스트 변환 추천         |

### 🧮 문자열 처리 핵심 알고리즘

#### 1️⃣ 패턴 매칭 (Pattern Matching)

| 알고리즘    | 시간복잡도    | 설명                |
| ----------- | ------------- | ------------------- |
| 브루트포스  | O(nm)         | 모든 위치에서 비교  |
| KMP         | O(n + m)      | 실패 함수 기반 스킵 |
| Rabin-Karp  | O(n + m) 평균 | 해시 기반 비교      |
| Z 알고리즘  | O(n)          | 접두사 기반 매칭    |
| Boyer-Moore | O(n) 평균     | 뒤에서 앞으로 매칭  |

> ✨ **패턴 매칭 문제**: "문자열 S에서 P가 처음 등장하는 위치를 찾아라"는 알고리즘 문제에 필수

#### 2️⃣ 문자열 해싱

- 문자열을 정수로 매핑하여 빠르게 비교
- 롤링 해시: `hash(s[i..j]) = hash(s[i..j-1]) * p + s[j]`
- 충돌 방지 위해 모듈러 연산 사용 (`mod 1e9+7`, `mod 2^64` 등)

#### 3️⃣ 트라이(Trie) 자료구조

- 문자열 집합을 **트리 형태로 압축 저장**
- 자동완성, 사전, 접두사 검색 등에 사용

```
예: "cat", "can", "car"

    (root)
     └─ c
         └─ a
             ├─ t
             ├─ n
             └─ r
```

### 🧠 자주 사용되는 문자열 관련 문제 유형

| 문제 유형           | 설명                                   |
| ------------------- | -------------------------------------- |
| 아나그램 판단       | 두 문자열이 동일한 문자 구성인지 비교  |
| 회문 여부           | 좌우 대칭 확인                         |
| 가장 긴 부분 문자열 | 조건 만족하는 최대 길이 구하기         |
| 압축/해제           | Run-Length Encoding, Decoding          |
| 문자열 압축         | 중복 문자 압축 (e.g., `aabb` → `a2b2`) |
| 다중 패턴 검색      | Aho-Corasick 알고리즘 사용             |

### 💡 실전 예시 (파이썬)

```
# 문자열 뒤집기
s = "abcdef"
print(s[::-1])  # 출력: 'fedcba'

# 부분 문자열 포함 여부
if "abc" in s:
    print("포함됨")

# 문자열 정렬
s = "dcba"
print("".join(sorted(s)))  # 출력: 'abcd'
```

### ⚠️ 문자열 다룰 때 주의할 점

| 문제        | 설명                                                |
| ----------- | --------------------------------------------------- |
| 복사 비용   | 문자열 변경 시 새로 생성되므로 성능 저하 가능       |
| 문자열 비교 | 언어에 따라 `==`는 값비교, `is`는 참조비교          |
| 유니코드    | 유니코드(한글, 이모지 등) 다룰 땐 UTF-8 인코딩 주의 |
| O(n^2) 이슈 | 문자열 연결 반복 시 `s += c`는 비효율 → `join` 사용 |

### 🔧 언어별 문자열 특징 정리

| 언어       | 불변성 | 유니코드 지원  | 메서드/클래스                 |
| ---------- | ------ | -------------- | ----------------------------- |
| C          | ✗      | ✗ (ASCII 기반) | `strcpy`, `strcmp`, `strlen`  |
| C++        | △      | UTF-8 가능     | `std::string`, `std::wstring` |
| Java       | ✅      | UTF-16         | `String`, `StringBuilder`     |
| Python     | ✅      | UTF-8/Unicode  | `str`, `re`, `collections`    |
| JavaScript | ✅      | UTF-16         | `String`, `RegExp`            |

### 💬 인터뷰에서 자주 나오는 질문

| 문제 유형                | 관련 알고리즘        |
| ------------------------ | -------------------- |
| 가장 긴 공통 부분 문자열 | DP, 해싱             |
| 회문 부분 문자열         | 투포인터, DP         |
| 문자열 압축              | 구현, 문자열 연산    |
| 패턴 포함 여부           | KMP, Rabin-Karp      |
| 트라이 응용 문제         | 자동 완성, 사전 구현 |

# 1.3 비선형 자료구조 (Non-Linear Data Structures)

## 트리(Tree)

### 📌 개념 정의

**트리(Tree)**는 **계층적(계급적) 구조**를 나타내는 **비선형 자료구조**로, **노드(node)**들이 간선(edge)으로 연결되어 있으며, **사이클이 없는 그래프**다.

- 각 노드는 **부모 노드와 자식 노드**를 가질 수 있음
- 루트 노드에서 시작하여 가지(branch)처럼 뻗어 나감
- **한 노드에서 다른 노드까지의 경로는 유일함**

### 🧠 트리의 용어 정리

| 용어              | 정의                              |
| ----------------- | --------------------------------- |
| 루트(Root)        | 트리의 시작 노드                  |
| 리프(Leaf)        | 자식이 없는 노드                  |
| 부모(Parent)      | 한 노드의 상위 노드               |
| 자식(Child)       | 한 노드의 하위 노드               |
| 형제(Sibling)     | 같은 부모를 공유하는 노드들       |
| 서브트리(Subtree) | 어떤 노드를 루트로 하는 하위 트리 |
| 높이(Height)      | 루트에서 리프까지의 최대 거리     |
| 깊이(Depth)       | 루트로부터 특정 노드까지의 거리   |
| 차수(Degree)      | 노드가 가진 자식의 수             |

### 🌲 트리의 종류

#### 1️⃣ 일반 트리 (General Tree)

- 자식의 수에 제한 없음
- 실전에서는 잘 사용되지 않음 (코드 구조상 비효율)

#### 2️⃣ 이진 트리 (Binary Tree)

- 각 노드가 **최대 두 개의 자식**을 가짐 (left, right)

#### 3️⃣ 포화 이진 트리 (Full Binary Tree)

- 모든 노드가 0개 또는 2개의 자식만 가짐

#### 4️⃣ 완전 이진 트리 (Complete Binary Tree)

- 마지막 레벨을 제외하고는 꽉 차 있고, 마지막은 왼쪽부터 채워짐

#### 5️⃣ 균형 이진 트리 (Balanced Binary Tree)

- 모든 리프 노드의 높이 차이가 1 이하
- 예: AVL, Red-Black Tree

#### 6️⃣ 이진 탐색 트리 (BST: Binary Search Tree)

- 왼쪽 서브트리 < 루트 < 오른쪽 서브트리

#### 7️⃣ 힙 트리 (Heap)

- 완전 이진 트리 + 힙 속성 (부모 ≥ 자식 or 부모 ≤ 자식)

#### 8️⃣ 트라이(Trie)

- 문자열 검색에 최적화된 트리형 자료구조 (문자 기반 인덱스)

#### 9️⃣ 세그먼트 트리 / 펜윅 트리

- 구간 쿼리(range query) 최적화용 트리

### ⚙️ 트리 구현 (C언어 예제 – 이진 트리)

```
typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} Node;

Node* create(int value) {
    Node* newNode = malloc(sizeof(Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}
```

### 🔁 트리 순회 (Tree Traversal)

#### 전위 순회 (Preorder: Root → Left → Right)

```
1. 노드 방문
2. 왼쪽 서브트리 순회
3. 오른쪽 서브트리 순회
```

#### 중위 순회 (Inorder: Left → Root → Right)

- **BST에서 오름차순 정렬 결과 출력**

#### 후위 순회 (Postorder: Left → Right → Root)

- **메모리 해제 시 유용 (자식부터 제거)**

#### 레벨 순회 (Level-order: BFS 방식)

- 큐(Queue)를 이용해서 레벨별 탐색

### 📊 시간/공간 복잡도

| 연산         | 이진 탐색 트리 평균 | 이진 탐색 트리 최악 (Skewed) |
| ------------ | ------------------- | ---------------------------- |
| 탐색(Search) | O(log n)            | O(n)                         |
| 삽입(Insert) | O(log n)            | O(n)                         |
| 삭제(Delete) | O(log n)            | O(n)                         |
| 공간복잡도   | O(n)                | O(n)                         |

> ✅ AVL, Red-Black Tree는 항상 O(log n)을 보장

### 🧭 트리의 실전 활용 사례

| 분야         | 활용 예                      |
| ------------ | ---------------------------- |
| 파일 시스템  | 디렉토리 구조                |
| 운영체제     | 스케줄링 트리, 페이지 테이블 |
| 인공지능     | 의사결정 트리, 게임 트리     |
| 데이터베이스 | B-Tree, B+ Tree 인덱스       |
| 그래픽스     | BSP 트리, 씬 그래프          |
| 문자열 처리  | 트라이, 서픽스 트리          |
| 웹 브라우저  | DOM 트리                     |

### 💡 실전 문제 유형

| 문제 유형                       | 설명                               |
| ------------------------------- | ---------------------------------- |
| 이진 트리 직렬화/역직렬화       | 트리 구조를 배열/문자열로 표현     |
| 최소 공통 조상 (LCA)            | 두 노드의 공통된 가장 가까운 조상  |
| 균형 여부 판단                  | AVL 속성 만족 여부                 |
| 경로의 합 문제                  | 특정 합이 되는 루트-리프 경로 탐색 |
| 최대 깊이/최소 깊이             | BFS, DFS를 이용한 깊이 측정        |
| 뷰 문제 (Top/Bottom/Left/Right) | 특정 방향에서 본 노드들 출력       |

### 🧠 트리 vs 그래프

| 항목   | 트리                 | 그래프                 |
| ------ | -------------------- | ---------------------- |
| 방향성 | 명확함 (부모 → 자식) | 방향/무방향 모두 가능  |
| 루트   | 하나만 존재          | 없음 or 다수 존재 가능 |
| 사이클 | 없음                 | 존재 가능              |
| 연결성 | 전체 연결됨          | 연결되지 않을 수 있음  |

### 🛠️ 고급 트리: 세그먼트 트리 & 펜윅 트리

- 구간의 합/최댓값/곱 등을 빠르게 처리
- 배열 기반으로 구현 → 트리처럼 작동
- 시간복잡도: O(log n) 업데이트, O(log n) 쿼리

### ⚠️ 주의 사항

| 문제점         | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| Skewed Tree    | 편향되면 선형 구조가 되어 O(n)                               |
| 순회 순서 실수 | DFS, BFS 순서 헷갈릴 수 있음                                 |
| 재귀 깊이 초과 | 깊은 트리에서는 stack overflow 가능 (→ 반복식 or tail recursion 사용) |

## 그래프(Graph)

### 📌 개념 정의

**그래프(Graph)**는 **정점(Vertex)**들과 **간선(Edge)**들로 구성된 자료구조로, **객체 간의 관계**를 표현하는 데 쓰인다.
 트리가 **계층적**이라면, 그래프는 **일반적 관계**를 다룬다.

```
예시:
정점 V = {A, B, C}
간선 E = {(A, B), (B, C), (C, A)} ← 순환 있음
```

### 📂 핵심 구성 요소

| 구성 요소          | 설명                             |
| ------------------ | -------------------------------- |
| 정점(Vertex, Node) | 그래프를 구성하는 개체           |
| 간선(Edge)         | 정점 간의 연결 (관계)            |
| 방향(Directed)     | 간선에 방향 존재 (A → B)         |
| 무방향(Undirected) | 양방향 관계 (A — B)              |
| 가중치(Weight)     | 간선에 숫자 부여 (거리, 비용 등) |
| 사이클(Cycle)      | 경로 중 다시 시작점으로 돌아옴   |
| 연결 그래프        | 모든 정점이 연결됨               |

### 🎨 그래프 표현 방법

#### 1️⃣ 인접 행렬 (Adjacency Matrix)

- 2차원 배열 사용
- 정점 수가 적고 간선 수가 많을 때 적합 (밀집 그래프)

```
노드: A(0), B(1), C(2)
0: A—B, B—C, C—A

    A B C
A [ 0 1 1 ]
B [ 1 0 1 ]
C [ 1 1 0 ]
```

- 메모리: O(V²)
- 간선 존재 여부 확인: O(1)

#### 2️⃣ 인접 리스트 (Adjacency List)

- 각 정점에 연결된 리스트 저장
- 간선이 적은 경우 적합 (희소 그래프)

```
vector<int> graph[100];
graph[0].push_back(1);  // A—B
graph[1].push_back(2);  // B—C
graph[2].push_back(0);  // C—A
```

- 메모리: O(V + E)
- 이웃 순회: O(degree)

### 📊 그래프의 종류 정리

| 분류 기준 | 유형               | 설명                  |
| --------- | ------------------ | --------------------- |
| 방향성    | 방향 그래프        | A → B (일방)          |
|           | 무방향 그래프      | A — B (쌍방)          |
| 가중치    | 가중치 그래프      | 간선마다 비용 부여    |
|           | 비가중치 그래프    | 모든 간선 동일 비용   |
| 연결성    | 연결 그래프        | 모든 정점이 연결      |
|           | 비연결 그래프      | 고립된 노드 존재 가능 |
| 순환성    | 순환 그래프        | 사이클 존재           |
|           | 비순환 그래프(DAG) | 방향 있고 사이클 없음 |

### 🔁 그래프 탐색 알고리즘

#### 1️⃣ DFS (Depth-First Search, 깊이 우선 탐색)

- 스택 또는 재귀 사용
- 한 방향으로 끝까지 탐색, 백트래킹

```
void dfs(int v) {
    visited[v] = true;
    for (int u : graph[v])
        if (!visited[u]) dfs(u);
}
```

- 시간 복잡도: O(V + E)

#### 2️⃣ BFS (Breadth-First Search, 너비 우선 탐색)

- 큐 사용
- 현재 정점에서 가까운 정점부터 순서대로 탐색

```
void bfs(int v) {
    queue<int> q;
    q.push(v);
    visited[v] = true;

    while (!q.empty()) {
        int cur = q.front(); q.pop();
        for (int u : graph[cur]) {
            if (!visited[u]) {
                visited[u] = true;
                q.push(u);
            }
        }
    }
}
```

- 최단 거리 탐색에 자주 사용 (단위 가중치 그래프에서)

### 🧠 그래프 관련 고급 알고리즘

| 알고리즘                 | 용도 / 설명                    |
| ------------------------ | ------------------------------ |
| **다익스트라**           | 최단 경로 (음수 가중치 X)      |
| **벨만-포드**            | 음수 가중치 포함 가능          |
| **플로이드 워셜**        | 모든 정점 쌍 간 최단 경로      |
| **크루스칼**             | 최소 신장 트리 (MST)           |
| **프림**                 | MST (우선순위 큐 기반)         |
| **위상 정렬**            | DAG의 정점 순서 (순환 없을 때) |
| **강한 연결 요소 (SCC)** | Kosaraju, Tarjan 알고리즘      |
| **유니온 파인드 (DSU)**  | 사이클 탐지, 분리 집합         |

### 🧭 그래프 활용 사례

| 분야            | 설명                      |
| --------------- | ------------------------- |
| 네트워크 라우팅 | 최단 경로, 연결 상태      |
| 웹 페이지 링크  | 방향 그래프 구조          |
| 소셜 네트워크   | 친구 관계, 연결 요소      |
| 게임 개발       | 맵, AI 이동, 충돌 판단    |
| 컴파일러        | 위상 정렬로 종속성 해석   |
| 회로 분석       | DAG 분석, 회로 시뮬레이션 |

### 🧮 시간 및 공간 복잡도 비교

| 표현 방식   | 메모리   | 인접 정점 탐색 |
| ----------- | -------- | -------------- |
| 인접 행렬   | O(V²)    | O(V)           |
| 인접 리스트 | O(V + E) | O(degree)      |

### 💡 실전 문제 유형

| 문제 유형       | 알고리즘/기법      |
| --------------- | ------------------ |
| 최단 거리       | BFS, 다익스트라    |
| MST             | 크루스칼, 프림     |
| 사이클 검출     | DFS, 유니온 파인드 |
| 위상 정렬       | 진입 차수 + 큐     |
| 연결 요소 분리  | DFS, BFS           |
| 2분 그래프 판별 | BFS 컬러링         |

### ⚠️ 그래프 알고리즘 실수 주의

| 문제                       | 설명                                     |
| -------------------------- | ---------------------------------------- |
| 방문 체크 누락             | DFS/BFS에서 중복 방문 방지 필수          |
| 방향성 혼동                | 무방향/방향 그래프 인접 리스트 구성 주의 |
| 음수 간선                  | 다익스트라 사용 불가 (→ 벨만포드 사용)   |
| 인접 행렬/리스트 전환 실수 | 시간/공간 낭비 발생 가능                 |

### 🧠 그래프 vs 트리 비교 요약

| 항목      | 트리            | 그래프                  |
| --------- | --------------- | ----------------------- |
| 연결성    | 계층 구조       | 임의의 연결             |
| 간선 수   | V - 1           | 최대 V² 가능            |
| 사이클    | 없음            | 존재 가능               |
| 루트      | 하나 (보통)     | 없음 또는 다수 가능     |
| 활용 분야 | 구조 표현, 탐색 | 관계 표현, 최단 경로 등 |

# 1.4 해시 기반 자료구조

## 해시 테이블(Hash Table)

### 📌 개념 정의

**해시 테이블(Hash Table)**은 **키(Key)를 해시 함수(Hash Function)를 통해 인덱스로 변환하고**, 이를 배열에 저장하는 구조다.

```
key → [hash function] → index → [배열[index]에 저장]
```

- 일반적인 배열은 인덱스로 직접 접근
- 해시 테이블은 **키 기반으로 직접 접근** 가능 → 평균 O(1)

### 🧠 기본 구성 요소

| 요소          | 설명                                 |
| ------------- | ------------------------------------ |
| 키 (Key)      | 고유한 식별자 (문자열, 정수 등)      |
| 값 (Value)    | 키에 대응하는 데이터                 |
| 해시 함수     | 키를 배열 인덱스로 변환              |
| 버킷 (Bucket) | 충돌 발생 시 여러 값을 저장하는 방식 |

### 🎲 해시 함수 (Hash Function)

해시 함수는 **키를 고정된 범위의 정수(인덱스)**로 변환하는 함수

```
int hash(int key) {
    return key % table_size;
}
```

좋은 해시 함수는:

- 빠르다
- 충돌을 최소화한다
- 키가 고르게 분포되도록 한다

### 💥 충돌(Collision) 처리 방법

#### 1️⃣ 체이닝 (Chaining)

- 같은 인덱스에 여러 값을 **연결 리스트**로 저장

```
table[hash] = head → node1 → node2 ...
```

- 구현이 간단하고 확장성 좋음
- 탐색 시 최악 O(n) (리스트 길이에 따라)

#### 2️⃣ 오픈 어드레싱 (Open Addressing)

- 충돌 발생 시 **다음 빈 슬롯**을 찾아 저장

#### 주요 방식

| 방식      | 설명                                         |
| --------- | -------------------------------------------- |
| 선형 조사 | `i+1, i+2, ...` 순서로 찾음 (Linear Probing) |
| 제곱 조사 | `i+1², i+2², ...` (Quadratic Probing)        |
| 이중 해싱 | 두 개의 해시 함수 사용 (Double Hashing)      |

> 오픈 어드레싱은 **배열 크기보다 적은 키만 저장**해야 함 (로드 팩터 제한)

### 🧪 로드 팩터 (Load Factor)

```
α = n / m

n = 저장된 항목 수  
m = 테이블 크기 (버킷 수)
```

- α가 높을수록 충돌 가능성 증가
- 일반적으로 α ≤ 0.75 유지 → **재해싱(rehashing)** 필요

### 🔁 재해싱 (Rehashing)

- 해시 테이블 크기가 포화되면 **더 큰 테이블을 새로 할당**하고 데이터를 다시 해싱하여 이동

```
- 테이블 크기 8 → 16
- 모든 기존 키 → 새로운 해시 함수로 재삽입
```

### 📐 해시 테이블의 시간복잡도

| 연산 | 평균 시간복잡도 | 최악 시간복잡도     |
| ---- | --------------- | ------------------- |
| 삽입 | O(1)            | O(n) (충돌 많을 때) |
| 삭제 | O(1)            | O(n)                |
| 탐색 | O(1)            | O(n)                |

> 좋은 해시 함수 + 적절한 충돌 처리 = O(1) 유지

### 📦 언어별 내장 해시 자료구조

| 언어   | 자료구조             | 구현 방식                |
| ------ | -------------------- | ------------------------ |
| C      | 직접 구현 필요       | 체이닝 추천              |
| C++    | `unordered_map`      | 해시 + 체이닝            |
| Java   | `HashMap`, `HashSet` | 해시 + 체이닝 + 리밸런싱 |
| Python | `dict`, `set`        | 오픈 어드레싱 + 해시     |
| Go     | `map`                | 내부 최적화 해시 구조    |

### 🧭 해시 테이블의 주요 활용 예시

| 분야         | 설명                     |
| ------------ | ------------------------ |
| 캐시 시스템  | 빠른 키-값 조회          |
| 중복 제거    | 이미 본 값 저장용        |
| 집합/맵 구현 | Set, Map 자료구조        |
| 문자열 문제  | 아나그램, 빈도 카운트    |
| DB 인덱싱    | 해시 인덱스 기반 검색    |
| 보안         | 비밀번호 해싱, SHA256 등 |

### 🧠 실전 문제 유형

| 문제 유형      | 예시 문제                                |
| -------------- | ---------------------------------------- |
| 중복 탐지      | "숫자 중복이 있는가?"                    |
| 두 수의 합     | "Two Sum" (Leetcode)                     |
| 빈도 카운트    | "가장 자주 등장한 문자"                  |
| 해시 집합 비교 | "두 문자열이 같은 문자 집합을 가지는가?" |
| 롤링 해시      | 문자열 검색 (Rabin-Karp)                 |

### ☠️ 해시 테이블 설계 시 주의점

| 문제                | 설명                                                      |
| ------------------- | --------------------------------------------------------- |
| 충돌 무시           | 충돌이 없다고 가정하면 절대 안 됨                         |
| 해시 함수 선택      | 나쁜 해시 함수는 편향 발생 (→ 많은 충돌)                  |
| 로드 팩터 과다      | 성능 저하, 재해싱 타이밍 고려                             |
| 키 비교/동등성 오류 | 객체 키는 `equals()`와 `hashCode()` 일관성 필요 (Java 등) |
| 메모리 낭비         | 너무 큰 초기 버킷 크기 설정 시 공간 낭비                  |

### 🔒 보안 해시 vs 일반 해시

| 구분      | 목적               | 예시                           |
| --------- | ------------------ | ------------------------------ |
| 일반 해시 | 자료구조 성능 향상 | `mod`, `multiplicative hash`   |
| 보안 해시 | 원본 보호/서명     | `SHA-256`, `MD5` (X), `BLAKE3` |

### 💬 인터뷰에서 자주 나오는 질문

- 해시 테이블을 어떻게 구현할 건가요?
- 충돌 처리는 어떻게 하죠?
- HashMap과 TreeMap 차이점은?
- HashSet은 내부적으로 어떻게 동작하나요?
- 재해싱 조건은 언제이고 비용은 어떤가요?

### 🔎 해시 테이블 vs 이진 탐색 트리(BST)

| 항목           | 해시 테이블      | 이진 탐색 트리 (BST) |
| -------------- | ---------------- | -------------------- |
| 검색 속도      | O(1) 평균        | O(log n)             |
| 정렬 순서      | 없음             | 있음 (Inorder)       |
| 충돌/균형 처리 | 필요             | 필요                 |
| 키 타입 제한   | 반드시 해시 가능 | 비교 연산자 필요     |

## 집합(Set), 맵(Map)

### 1️⃣ 집합 (Set)

#### 📌 개념 정의

- Set은 **중복을 허용하지 않는 원소들의 집합**
- 원소의 존재 여부만 중요 (`"이게 있는가?"`)
- 내부적으로 **해시 테이블 또는 균형 트리**로 구현됨

#### 🧠 주요 연산

| 연산          | 설명                       | 시간복잡도 (HashSet 기준) |
| ------------- | -------------------------- | ------------------------- |
| `add(x)`      | x를 추가                   | O(1) 평균                 |
| `remove(x)`   | x를 제거                   | O(1) 평균                 |
| `contains(x)` | x가 집합에 존재하는지 확인 | O(1) 평균                 |
| `size()`      | 집합 크기 반환             | O(1)                      |
| `clear()`     | 집합 비우기                | O(1)                      |

#### 🔧 예시 (Python)

```
s = set()
s.add(10)
s.add(20)
s.add(10)  # 중복 무시
print(10 in s)  # True
```

### 2️⃣ 맵 (Map) / 딕셔너리 (Dictionary)

#### 📌 개념 정의

- Map은 **키-값 쌍(Key-Value Pair)**을 저장하는 자료구조
- 키는 **중복 불가**, 값은 중복 가능
- 내부는 해시 테이블 (HashMap) 또는 트리 기반 (TreeMap)

#### 🧠 주요 연산

| 연산                 | 설명                    | 시간복잡도 (HashMap 기준) |
| -------------------- | ----------------------- | ------------------------- |
| `put(k, v)`          | 키 k에 값 v 저장        | O(1) 평균                 |
| `get(k)`             | 키 k에 대응하는 값 반환 | O(1) 평균                 |
| `remove(k)`          | 키 k와 해당 값 제거     | O(1) 평균                 |
| `containsKey(k)`     | k가 존재하는지 확인     | O(1) 평균                 |
| `keys()`, `values()` | 키/값 집합 반환         | O(n)                      |

#### 🔧 예시 (Python)

```
m = {}
m["apple"] = 100
m["banana"] = 200

print(m["apple"])     # 100
print("banana" in m)  # True
```

### 🧠 Set vs Map 비교

| 항목      | Set                     | Map                 |
| --------- | ----------------------- | ------------------- |
| 저장 형태 | 원소만 저장             | 키-값 쌍 저장       |
| 중복 허용 | X                       | 키 X, 값 O          |
| 사용 목적 | 존재 확인, 중복 제거 등 | 연관 데이터 저장    |
| 내부 구조 | 해시 테이블 or 트리     | 해시 테이블 or 트리 |

### 📊 HashSet / HashMap vs TreeSet / TreeMap

| 항목      | HashSet / HashMap   | TreeSet / TreeMap               |
| --------- | ------------------- | ------------------------------- |
| 정렬 여부 | 정렬 X (순서 없음)  | 자동 정렬 (오름차순 등)         |
| 내부 구조 | 해시 테이블         | 이진 탐색 트리 (Red-Black Tree) |
| 접근 속도 | O(1) 평균           | O(log n)                        |
| 용도      | 빠른 삽입/삭제/탐색 | 순서 기반 탐색이 필요할 때      |

### 🔁 OrderedSet / LinkedHashMap

- **Python 3.7+ dict / set**은 **입력 순서 유지**
- Java: `LinkedHashSet`, `LinkedHashMap` 제공
- Go: map은 기본 순서 없음
- C++: `std::unordered_set`, `std::set`, `std::map`, `std::unordered_map`

### 🧭 실전 활용 사례

#### Set 활용

| 문제 유형                | 설명                        |
| ------------------------ | --------------------------- |
| 중복 제거                | 배열 중복 제거 후 크기 비교 |
| 교집합 / 합집합 / 차집합 | `set & set`, `set           |
| 빠른 탐색                | 값이 존재하는지 O(1) 확인   |
| 아나그램 비교            | 문자 집합 비교 등           |

#### Map 활용

| 문제 유형          | 설명                                      |
| ------------------ | ----------------------------------------- |
| 빈도 카운트        | 문자열, 배열에서 각 원소의 등장 횟수 저장 |
| 캐시 구현          | 키-값으로 LRU 등                          |
| 역 인덱스 저장     | 학생 ID → 점수 등                         |
| 카운트 누적 / 정렬 | Map + PriorityQueue 조합                  |

### 🧠 실전 문제 예시

| 문제                     | 기술                        |
| ------------------------ | --------------------------- |
| Two Sum                  | Map (키: 숫자, 값: 인덱스)  |
| 중복 문자 제거           | Set                         |
| 가장 자주 나온 요소 찾기 | Map + Heap                  |
| Group Anagrams           | Map(정렬된 문자열 → 리스트) |
| 빈도 기반 정렬           | Map + Bucket Sort           |

### ☠️ 주의 사항

| 문제                                     | 설명                                             |
| ---------------------------------------- | ------------------------------------------------ |
| 키에 해시 가능한 자료형만 허용           | Python에서 list, dict 등 mutable 타입은 불가     |
| Map 반복 중 값 삭제 주의                 | ConcurrentModificationException 발생 가능 (Java) |
| 정렬되지 않은 Set/Map에서 순서 신뢰 금지 | 정렬된 결과가 필요하면 TreeSet, TreeMap 사용     |


